# XML语法  
### XML组成部分
* declaration(XML宣告):  
`<?xml version="1.0" encoding="utf-8"?>`  
在XML文件的首端 注明版本和文字编码(省略情况下默认为UTF-8)所以XML是完全支持中文的
* 元素:  
俗称标签(tags),最高层的元素称为 **根元素**.元素可以嵌套.  
`<元素名>元素内容</元素名>`
```
<根元素名>
    <子元素名1>子元素内容1</子元素名1>  
    <子元素名2>子元素内容2</子元素名2>  
    ...
</根元素名>
```
* 属性:  
元素可以有属性,写在元素头标签的元素名的后面,用不同的属性值来区分相同元素名的元素(属性可以有 **多个**) 属性看起来结构比子元素紧凑.  
`<元素名 属性1="属性值1">元素内容</元素名>`
* 注释:  
放在<\!--和 -->之间的区块,会作为注释,不会被解析器解析

### XML的相关特性
* 空元素:  
在HTML中自成一个单元(元素)的标签,如`<imgsrc = "fool">`.在XML中叫 **空元素**. 因为这样的元素不含任何内容.XML为空元素提供了特殊的语法:  
`<空元素名/>`或者`<空元素名 空元素属性="属性值"/>`
* 大小写可分:  
XML的元素和属性的名称是区分大小写的.
* 空格的区分:  
XML对空白字元严格解析,不会把空白去掉或缩减
* 格式正确  
在XML中的正式说法为"well-formed".任何XML文件的格式必须达到标准,才能够被解析器解析.主要有以下几个原则:  
  * 所有元素都要正确关闭  
  某个元素不管有多复杂,中间嵌套了多少子元素,在结尾必须有 **结束标签** 将该元素"关起来".  
  * 标签之间不能交叉  
  XML的元素排列遵循严格的 **树状结构**.如下的格式是非法的:  
  ```
  <元素1>  
      <元素2>
  </元素1>
      </元素2>
  ```
  * 所有属性值必须包有引号  
  在HTML中,网页浏览器可以对没有引号的属性值正确处理,但是在XML中这样是非法的
  * 名称空间(namespace)  
  如果每套XML语汇都各自用一个独一无二的标志来代表,在使用时把这个标志和语汇中的元素属性名连在一块使用,就不会和其它语汇的命名牵扯不清楚了.因为每个语汇中的名称,都已经先被该语汇的独特标示码给修饰,限制住了.
---
# XML Schema(XML架构)  
(DTD将会被XML Schema取代)  
XML 架构是用于定义和验证 XML 数据的内容和结构的文档，就像数据库架构定义和验证组成数据库的表、列和数据类型一样。
XML 架构通过 XML 架构定义 (XSD) 语言定义和描述某些 XML 数据类型。XML 架构元素（元素、属性、类型和组）用于定义某些 XML 数据类型的有效结构、有效数据内容和关系。XML 架构还可为属性和元素提供默认值.从本质上讲，XML架构本身也是一个XML，只不过它是 **用于描述其他XML数据的结构的**（或者称作限定更合适）
### XML Schema组成部分  
因为XML Schema本质也是XML 但是解释器会以特殊的方式解读XML Schema的内容,并将其架构元素绑定到其它XML,使其它XML受架构的规则约束.
### 写XML Schema的固定语法
* 在XML架构中,必须使用xs名称空间.时这个名字空间的URI名称必须是http://www.w3.org/2001/XMLSchema. 这是因为这个名字空间已经被W3C组织定义为一个标准的名字空间，专门用于定义XML架构信息(在vs中会写好开头部分)
* *element* 元素(标签):  
在XML Schema中,element描述了该标签映射XML中的一个元素
  * *name属性*:  
  在element元素中,name属性描述了element映射元素的元素名称.  
  `<xs:element name="book"/>`  
  描述XML文件中的:  
  `<book>...</book>`
  * *type属性*:   
  在element元素中,type属性描述了element映射元素的数据类型(有点黑人问号,难道不应该都是文本类型吗)
  * *minOccurs属性* & *maxOccurs属性*:  
  在element元素中,minOccurs和maxOccurs属性明确限定元素名为name的子节点的个数.如果在定义标记时,如果没有指定这两个属性时,此时它们的值默认都为1.(如果不想限制个数,可以定义maxOccurs="**unbounded**")
  * *ref属性*:  
  从本质上讲XML描述的是一个树型的数据.如果XML数据的层数太多,那么描述它的XML架构数据将不得不也嵌套很多层.从前面的描述中可以看出为了描述一个带有子标记的XML结构,不得不使用至少三层嵌套.这样就会使XML架构的可读性,可维护性大大降低.此时可以使用element的ref属性减少嵌套层次，同时改进可读性。
* *complexType(标记)*:  
```
<xs:complexType>  
...
</xs:complexType>
```  
表示前面的element标记定义的标记是一个“**复杂类型**”,既它至少要含有子元素(含有嵌套结构).特别需要注意的是这个标记的大小写方式.  
**注意!**: 该标记有一个 *mixed属性*,只有将mixed属性设为true,才能即有属性有有文本,大坑!
* *sequence(标记)*:  
嵌套在complexType标记之中的xsd:sequence标记表示其中出现的元素必须 **按照顺序排列**.
注意：利用定义子标记的方法，可以嵌套定义更复杂的XML数据
* *attribute*:  
attribute表示前面的element元素具有该条属性.定义属性和定义子元素比较相似,也可以指定名称,类型等.  
`<xs:attribute name="Name" type="xsd:string" use="required"/>`  
`<xs:attribute name="Age" type="xsd:int" default="18"/>`
  * *name属性*:  
  在attribute元素中,name属性描述了该attribute的属性名称
  * *type属性*:  
  在attribute元素中,type属性描述了该attribute的属性数据类型
  * *use属性*:  
  在attribute元素中,use="required"表示该attribute必须提供
  * *default属性*:  
  在attribute元素中,default="..."表示不提供该属性时attribute的默认值.(use和default应该只有一个吧)
  * *fixed属性*:  
  提供固定值.
* *choice标记*:  
**可选** 的子元素.如果在XML数据中某几个子元素是任选的,既不一定要全部出现时,可以使用可选子标记定义.
```
<xsd:choice>
    <xsd:element name="SID" type="xsd:long"/>
    <xsd:element name="Name" type="xsd:string"/>
</xsd:choice>
<xsd:element name="College" type="xsd:string"/>
<xsd:element name="Class" type="xsd:string"/>
```
---
# 使用元素还是属性?  
* 一个XML文档中,要对信息进行分类.  
  * 一类是以交换为目的的数据(这些数据可能会被重新使用和修改),如装备的描述信息,物品的属性信息.这类信息使用元素
  * 一类是以展现或辅助交换为目的的数据,作为获取第二类信息的一种索引而没有真正价值的信息(这类数据重要程度不高).如物品的ID.这类信息使用属性.
* 其它的判断标准  
  * 如果这个信息命名对于一个元素来说,最终可能出现多个,则使用元素来定义。
  * 属性不易扩展,只能支持简单数据类型.如果要定义的数据项将来可能扩展为复杂数据对象时,则应毫不犹豫地使用子元素.而且子元素在xml文档中更容易被解析
