# c\#相关

* 关于属性
  * public string CarName002{get;set;}
  属性简写(语法糖)不能加入复杂逻辑 并且简写后和内部的同名字段(大小写)不再有对应关系
  * 可以使用private set;使之对外界只读，对内部可写
  * 属性相当于对字段的一级封装，本质是CLR内部生成的辅助字段
  * ctrl+r+e 快速生成字段对应的属性
  * 抽象属性 一般只读，由字段的变化而变化，如面积属性
* 命名风格:
  * pascal风格 MyName 类名 属性 方法 接口 事件 枚举 命名空间
  * camel风格 myName  字段名 参数名 变量名
* 类及类型成员修饰符
  * 注意 **类** 前面没有修饰符默认internal修饰, **类型** 成员前面没有修饰符默认private修饰
  * public 任何地方该类(成员)都可以被访问到
  * internal 只有在同一程序集内该类才可以被访问到
  * protected 只有在该类(或其派生类)内部可以被访问，即其可被继承
  * private 只有在该类本身内部可以被访问
* sealed(密封) 防止其它类继承此类 修饰方法时刻防止派生类重写此方法
* abstract(抽象)修饰符
  * 可以用来修饰类，方法，属性，索引器，事件
  * 修饰类时:表示这个类只能是其它类的基类，且该类不能被实例化
  * 修饰方法时:没有方法体,即签名的后面没有大括号,并且抽象方法只允许在抽象类中声明，必须在子类中重写(强制派生类覆盖) 并且子类中重写的方法要用override修饰符修饰
* virtual(虚)修饰符
  * 允许子类对父类的此方法进行重写
  * 可以用来修饰方法，属性，所引起，事件
  * 修饰方法时，被称作虚方法，不强制派生类覆盖。而和普通方法无法，子类中用new关键字修饰的方法，是区别于其父类的同名方法，并不是重写，并不推荐
* is和as操作符来转型
  * is检查对象是否兼容于指定类型(所谓兼容 即指定类型为该对象的 *实际* 类型或其 **基类**  可以安全的直接进行显式转换) 返回Boolean值true或false 如果对象引用null则总是返回false 所以is永远不会抛出异常 通常用作类型转换前的判断条件
  if(o is String){ String s=(String)o; print("ok");}
  * as操作符检查对象类型的兼容性并返回转换结果,如果不兼容则回null 永远不会抛出异常 as操作符简化is使用情况下代码的写法使其比is少执行一次兼容性检查,性能高一点点
  String s=o as String;if(s!=null){ok;}else{wrong;}
* override(重写)和new(覆盖)的区别
  * C2类继承自C1类.C1 c=new C2();只有在使用这种语法的时候,重写和覆盖有所区别.这时候调用c的方法.比如c.Method();如果C2覆盖(使用new)了该方法,调用的仍然是原先父类的方法,如果C2重写(使用override)了该方法,调用的将是子类C2的覆盖方法.  
  `总结:`
  * 不管是重写还是覆盖,都不会影响父类自身的功能(废话,这是肯定的,否则有失常理)
  * 当用子类创建父类的时候，重写会改变父类的功能，即调用子类的功能；而覆盖不会，仍然调用父类功能。
  * 虚方法、实方法都可以被覆盖（new），抽象方法，接口 不可以。
  * 抽象方法，接口，标记为virtual的方法可以被重写（override），实方法不可以。
  * 重写使用的频率比较高，实现多态；覆盖用的频率比较低，用于对以前无法修改的类进行继承的时候。
* 目前认同的一些见解
  * 只有在必要的时候，才推荐使用var，也就是说当变量用来存储一个匿名类型或者匿名类型集合的时候。
* 关于一些基元类型的初始化数字字面量
  * 在 C# 中,一个带小数点的数字字面量默认是double类型的，后面加上f/F视为float类型,后面加上m/M视为decimal类型 如:  
  double a = 0.3;  //double类型  
  double a = 0.3f; //float类型隐式转换为double  
  float b = 0.3;   //报错,因为double无法隐式转换为float,会有精度损失  
  float b = (double)0.3; //double强制类型转换float  
  float b = 0.3f; //flaot类型  
  decimal c = 0.3m;//decimal类型
* 一些疑问
  * 委托封装了方法,事件又封装了委托,二次封装有什么意义?毕竟委托本身就可以直接调用方法
  * 属性是不是最好不要简写,否则容易将内部字段和属性联系到一起(实际上他们已经没有关系了)




---
# .NET/CLR相关

### 一、CLR执行模型
* CIL,托管模块(代码),JIT,跨语言特性
  * IL是.NET框架中中间语言（Intermediate Language）的缩写 有时也称为CIL通用中间语言(Common Intermediate Language) 　　　它是 **基于栈** 的
  * CLR实际上是提供了一项使用了虚拟机技术的产品，他在操作系统之上，并不要求程序的运行平台是 Windows系统，只要是能够支持它的运行库的系统，都可以在上面运行.NET应用。所以，一个完全由托管代码组成的应用程序，只要编译一次，就可以在任何支持.NET的平台上运行.（从Mono的出现变得更加真实啦,不用再羡慕JAVA啦）
  * 程序集的文件负责封装中间语言，由一个或多个托管模块和资源文件组成。托管模块主要包括(**元(托管)数据** 和 **IL** ),托管模块即托管PE文件(由PE32(+)头、CLR头、元数据以及IL)。如果源代码由c#语言编写，那么需要使用c#的面向 **CLR** 的编译器(而不是本机代码编译器)编译生成托管代码。由CLR管理它的执行
  * 源代码编译成托管代码(即中间语言IL)，而不是能够直接在本地运行的原生机器码。托管代码在公共语言运行时(CLR)中运行，优势是公共语言运行时为托管代码提供多种服务，如加载和验证程序集确保代码只进行类型安全的操作。当某些方法第一次被调用时，CLR把具体的托管代码方法编译成适合本地运行的机器码(不同平台有所差异如X86 X64 ARM等)并将其缓存，以备下次调用时使用。这个过程就是 **即时编译**(JIT编译 Just In Time) JIT编译造成的性能损失只是一次性的所以并不显著。
  * 所以.NET平台上的程序实际上是被 **托管** 在CLR中，随着程序集的运行，公共语言运行时会持续提供各种服务，如内存管理，安全管理，线程管理等。托管代码可以调用CLR的运行时服务和功能，如GC，类型检查，安全支持等等。这些服务和功能都是 **独立** 于开发语言的统一的Managed Code行为
    `相对应CLR编译器`             `JIT即时编译器`
  c#/vb等源代码————————>IL托管代码——————————>本机CPU指令
  * 通用类型系统:CTS(Common Type System)描述类型的定义和行为的正式的规范,称作CTS规范
  * 公共语言规范:CLS(Common Language Specification) 定义了所有语言都必须支持的 **最小** 功能。提炼CLS的规则即:在CLR中，类型的每个成员要么是字段，要么是方法。这意味着每种面向CLR的编程语言都必须能访问字段和调用方法~~同时为了简化编程，语言往往提供了额外的 *抽象* 从而对这些常见的编程模式进行简化。例如 语言会公开枚举,数组,属性,索引器,委托,事件,构造器,终结器,操作符重载,转化操作符等概念。编译器在源代码中遇到其中的 **任何一样**,都必须将其转换成字段和方法使CLR和其它任何编程语言能够访问这些构造
  * 每个类编译之后都会得到一个憨厚大量字段和方法的一个类型，可以使用反汇编工具ILDasm.exe查看生成的托管模块,在《CLR via c#》的27页列举了常见的编程语言构造与CLR字段/方法的映射关系
  * 编程人员选择的语言会采用其熟悉的方式公开它自己的语言语法与类型规则，通过编译生成程序集时，它会将语言特有的语法 **映射** 到IL——也就是CLR的“语言”，使用的语言不同，用于定义类型的语法也不同，但是无论使用哪种语言，类型的行为都完全一致

### 四、类型机制
* 所有类型都从System.Object派生
  * System.Object的公共方法Equals GetHashCode ToString GetType 保护方法MemberwiseClone Finalize
  * Equals:如果两个对象具有相同的值返回true
  * GetHashCode:返回对象的值的哈希码
  * ToString:经常重写该方法来返回包含对象状态表示的String对象 例如核心类型Boolean和Int32重写该方法返回他们的值的字符串表示
  * GetType:指出调用GetType的对象是什么类型 返回的Type对象可以和反射类配合获取与对象的类型有关的元数据信息 需要指出的是此方法是非虚方法防止派生类重写该方法隐瞒其类型破坏类型的安全性
  * MemberwiseClone:非虚方法，创建类型的新实例返回其引用
  * Fianlize:在GC判断对象应该作为垃圾被回收之后,在对象的内存被实际回收之前调用此虚方法(类似析构函数)
* new操作符所做的事情:
  * 1.计算类型以及所有基类型中定义的所有实例字段所需要的字节数(包括额外成员如类型对象指针同步快索引 CLR利用额外成员管理对象)
  * 2.从托管堆分配类型要求的字节数从而分配对象的内存,同时分配的所有字节都设为 **0**
  * 3.初始化对象的类型对象指针和同步块索引
  * 4.调用类型的实例构造器(在c#中即构造函数)并传递new调用中指定的实参.
  * CLR要求所有对象都用new操作符创建
  * new执行了所有的这些操作之后返回指向新对象的一个引用
  * 需要指出没有和new操作符对应的delete操作符 即在CLR中没有办法显式的释放为对象分配的内存而采用垃圾回收机制
* 类型转换
  * CLR的最重要的特性之一:类型安全 在运行时CLR总是知道对象的类型是什么 同时调用GetType即可知道对象的 **确切类型**
  * CLR允许将对象转换为它的(实际)类型或它的任何基类型
  * C#不要求任何特殊语法即可将对象转换为它的任何基类型,因为这被认为是一种安全的隐式转换 但是将对象转换为它的某个派生类型时,c#要求开发人员只能进行显示转换(有风险可能会抛出异常)
  * 如果转换后的类型既不是其基类型或原类型,则CLR会禁止此转型并抛出InvalidCastException异常(因为如果CLR允许这样的转型 就毫无类型安全性可言了.将出现难以预料的结果)**运行时抛出异常以防止使用错误的类型数据**
  * 值类型和引用类型的转换成为装箱(boxing)或拆箱(unboxing)
  * c#中基本类型可以使用Convert类实现类型转换
  * 使用GetType可以取得任何对象的精确类型
  * 转型时常用 as操作符
* 命名空间
  * 命名空间对相关的类型进行逻辑分组,开发人员可以通过命名空间方便的定位类型
  * 为了使用一种简单的方式直接引用命名空间中的类型(省去打很长很麻烦的前缀)c#编译器通过using指令提供这个机制
  * 对于编译器,命名空间的作用就是 **为类型名称附加以句点为分割的符号而使名称变得更长,更可能具有唯一性**
  * C#的using指令是可选的,如果愿意完全可以输入类型的完全限定名称.**C#的using指令编译器尝试为类型名称附加不同的前缀,直至找到匹配项**
  * CLR对命名空间一无所知,访问类型时CLR需要知道类型的完整名称(可能是相当长的包含句点符号的名称)以及该类型的定义具体在哪个程序集中
  * 若存在同名的类型,为了消除歧义,引用时需要使用完全限定名称区分它们,否则c#编译器会报告错误消息指明这是"不明确的引用"
  * 如果只想使用命名空间的少量类型而不像让它的所有类型都跑出来 **污染** 全局命名空间,可以使用using指令的另一种形式为类型或命名空间创建别名
  如using WintellectWidget = Wintellect.Widget;
  所以要在库中设计由第三方使用的类型 应该在专门的命名空间中定义这些类型 这样编译器可以轻松消除这些歧义
  * 创建命名空间很简单,以C#为例                    
  >namespace CompanyName{  
  >public sealed class A{}//TypeDef:CompanyName.A   
  >namespace X{  
  >  public class B{}//TypeDef:CompanyName.X.B    
  >}  

    右侧TypeDef注释是编译器在类型定义元数据表中添加的实际类型名称 这是CLR看到的类型名称
  * 命名空间可以极大减少打字 还能增强代码可读性  
* 类型,对象,线程栈,托管堆在运行时的相互关系
  * windows进程可能有多个线程,线程创建时会分配1MB的栈,栈空间用于向方法传递实参,同时也用来存放方法内部定义的局部变量
  * 调用方法前会将"返回地址"压入线程栈,方法抵达其return语句时,造成CPU的指令指针被设置成栈中的"返回地址",被调用方法的栈帧展开(unwind),恢复调用前的样子
  * JIT编译器将方法的IL代码转换成本机CPU指令时会注意到方法内部引用的所有类型,包括Int32,String,Employee等类型,当CLR确认了定义这些类型的程序集都已加载然后利用程序集的元数据提取与这些类型有关的信息,**在堆上** 创建一种数据结构开辟一块空间表示 **类型本身**(而不是类的对象),称之为 **类型对象** (区别于实例对象) .堆上的类型对象上的数据包括
    * *类型对象指针*
    * *同步块索引*
    * *静态字段:* 为类的静态字段提供支援的字节在类型对象自身中分配
    * *方法表:* 类型定义的每个方法都有对应的记录项
    当CLR确认方法需要的所有类型对象都已创建,待执行方法已经编译后,就允许线程执行方法的本机代码 CLR会自动将所有的局部变量初始化为 **null或0**　如果代码视图访问尚未显式初始化的局部变量,C#会报错:使用未赋值的局部变量
  * 托管堆上所有对象都包含两个额外成员:类型对象指针(type object pointer)和同步块索引(sync block index)
    * 类型对象指针: 任何时候在托管堆上新建对象,CLR都自动初始化实例对象内部的"类型对象指针"成员用来引用和对象相应的类型对象
    * 同步块索引: 待深入学习
  * 使用new操作符时,会在托管堆上创建一个实例对象(分配内存操作),实例对象上的数据包括:
    * 类型对象指针
    * 同步块索引
    * 实例数据字段以及容纳任何基类定义的所有实例字段
  * 类型对象同样包含类型对象指针成员,因为类型对象其本身也是对象,CLR创建类型对象的时候也会初始化这些成员.CLR开始在一个进程中运行时会立即(在托管堆中?)为MSCorLib.dll中定义的System.Type类型创建一个特殊的类型对象,其它类型对象都是该类型的实例,因此它们的类型对象指针成员会初始化成对System.Type类型对象的引用,然后System.Type在托管堆中同样也有类型对象指针,它指向它本身
  * System.Object.GetType方法返回存储在指定对象的类型对象指针成员中的地址,这样就可以判断系统中任何对象(包括类型对象本身)的真实类型
* CLR调用静态方法,非虚实例方法,虚实例方法的区别
  * 调用静态方法时: CLR会定位与定义静态方法的类型对应的类型对象,然后JIT编译器在类型对象的方法表中查找与被调用方法对应的记录项,对方法进行JIT编译(如果是第一次调用的话) 再调用JIT编译好的本机代码
  * 调用非虚实例方法时: JIT编译器会找到与发出调用的那个变量的类型在托管堆上对应的类型对象,如果再该类型对象中没有定义待调用的方法,JIT编译器会回溯类层次结构(一直回溯到Object)并在沿途的每个类型中查找该方法对应的记录项,因为每个类型对象都有一个字段引用了它的基类型
  * 调用虚实例方法时 与调用非虚实例方法类似,只是最后执行的是派生类重写的版本

### 五、基元类型,引用类型和值类型
* 基元类型
  * 使用System.Int32 a=new System.Int32();这种语法声明并初始化整数太繁琐,使用int a=0;增强了代码可读性,生成的IL代码与System.Int32生成的完全一致,编译器直接支持这样的数据类型成为 **基元类型** ,基元类型直接映射到Framework类库(FCL)中存在的类型
  * C#编译器非常熟悉基元类型,在编译代码时使用自己的特殊规则,支持与类型转换,字面值以及操作符有关的模式.编译器能够实现基元类型之间的隐式或显示转型(**尽管他们之间并没有派生关系**) 当转换被认为是"安全"(即不丢失数据精度或数量级)的时候,C#编译器才允许隐式转型,"不安全"的转型被要求使用显式转型 不同的编译器有可能生成不同的代码来处理这些转型.
  * 对基元类型执行运算时可能造成溢出,不同语言处理溢出的方式不同.C/C++不将溢出视为错误并允许值回滚,VB总将溢出视为错误并抛出异常 CLR提供了一些特殊的IL指令允许编译器选择它认为最恰当的行为,C#允许程序员自己决定如何处理溢出,溢出检查 **默认关闭** 可以使用/checked+编译器开关全局地打开或关闭溢出检车,c#也可以通过checked和unchecked操作符在代码的特定区域控制溢出检查 checked语句(操作符)唯一的作用是决定生成哪个版本的加减乘和数据转换的IL指令 不会对调用的方法造成任何影响
  * 作者对使用基元类型的几点建议:
    * 建议开发人员使用FCL类型名称 考虑到需要深层次理解其本质的原因
    * 尽量使用有符号数值类型,可以有效减少需要进行的强制类型转换,使代码更整洁容易维护, 并且, 无符号数值类型不符合CLS
    * 如果代码可能发生不希望的溢出(可能是因为无效的输入) 就把这些代码放到checked块中,同时捕捉OverFlowException得体地从错误中恢复
    * 在开发应用程序时,可以打开编译器的/checked+开关进行调试性生成,这样系统会对没有显式编辑checked的代码进行溢出检查,所以应用程序会运行起来慢一些,但是此时发生异常可以轻松检测到并及时修正代码中的bug;在正式发布应用程序时,应当使用编译器的/checked-开关,确保代码更快运行而不会产生溢出异常
  * C#基元类型与对应的FCL类型


  | C#基元类型|FCL类型|说明|
  | ------------- |:-------------:| -----:|
  | sbyte | System.SByte |有符号8位值|
  | byte  | System.Byte  |无符号8位值|
  | short | System.Int16 |有符号16位值|
  | ushort | System.UInt16 |无符号16位值|
  | int | System.Int32 |有符号32位值|
  | uint | System.UInt32 |无符号32位值|
  | long | System.Int64 |有符号64位值|
  | ulong | System.UInt64 |无符号64位值|
  | char | System.Char |16位Unicode字符|
  | float | System.Single |IEEE32位浮点值|
  | double | System.Double |IEEE64位浮点值|
  | bool | System.Boolean |true/false值|
  | string | System.String |字符数组|
  | object | System.Object |所有类型的基类型|

  从另一个角度来看,可以认为C#编译器自动假定所有源代码文件都添加了类似 using int=System.Int32;的using指令
* 引用类型和值类型
  * CLR支持两种类型,**引用类型**和**值类型** FCL中的大多数类型是引用类型,但程序员用的最多的是值类型
  * 引用类型从托管堆中分配 C#的new操作符返回对象内存地址
  * 关于引用类型的性能问题 认清下述事实
    * 内存必须从托管堆分配
    * 堆上分配的每个对象都有一些额外成员(类型对象指针和同步块索引?),这些成员必须初始化
    * 对象中的其他字节(为字段开辟的内存空间)总是设为**零**
    * 从托管堆分配对象时,可能强制执行一次垃圾回收(在内存不足的时候?)
  * 引用类型会使应用程序的性能下降,为了提升简单和常用的类型的性能,CLR提供了名为 **值类型** 的轻量级类型,值类型的实例在线程栈上分配(虽然也可作为字段嵌入引用类型的对象中)代表值类型的变量不包含只想实例的指针,而直接代表实例本身的字段.所以操作实例的字段不需要 **提领指针** ,并且值类型的实例不受垃圾回收器的控制.值类型的使用缓解了托管堆的压力,减少了用用程序生存期内的垃圾回收次数
  * 任何称为"类"(**class**)的类型为引用类型,所有结构(**struct**)或枚举(**enum**)都是值类型 根据定义,所有值类型都由Syste.ValueType派生: 所有结构类型都是System.ValueType的直接派生类,System.ValueType又直接从System.Object派生.所有枚举都由System.Enum抽象类型派生,而System.Enum又从System.ValueType派生.同时 在托管环境中CLR给予枚举类型特殊待遇,将其视为一等公民并提供各种强大的操作
  * 所有值类型都隐式密封,目的是防止将值类型用作其它类型的基类型,我们无法将Boolean,Char,Int32,Single,Double(这些基元类型都是结构体)等作为基类型来定义任何类型
  * 在非托管C/C++声明类型时,使用该类型的代码会决定在线程栈上还是在应用程序的堆上分配类型实例,但是在托管代码中,要由定义类型的开发人员决定在什么地方分配类型实例(如果定义的是值类型分配在线程栈中,若是引用类型分配在托管堆重) 使用类型的人对此无控制权
  * 一般情况下 我们很少使用自定义的结构(非FCL中提供的) 除非满足下列条件,否则不应声明为值类型
    * 类型具有基元类型的行为,是十分简单的类型
    * 类型不需要从其它任何类型继承
    * 类型也不派生出其它任何类型
    * 类型的实例较小(小于16字节)
    * 类型的实例较大(大于16字节) 但是不作为方法实参传递也不从方法返回
  * 值类型和引用类型的一些区别
    * 值类型对象有两种表示形式,**未装箱** 和 **已装箱** ,相反,引用类型总是处于 **已装箱** 形式
    * System.ValueType重写了Equals方法,在两个对象的字段值完全匹配的前提下返回true
    * 值类型中不能引入任何虚方法,所有方法都是不可抽象的,都是隐式密封(不可重写)的
    * 将值类型变量赋给另一个值类型变量,会进行逐字段的复制;将引用类型的变量赋给另一个引用类型变量只复制内存地址,所以赋值之后两个引用类型变量会引用堆中同一个对象,对一个变量执行的操作会影响到另一个变量.相反,值类型变量自成一体,对值类型变量执行的操作不可能影响其它值类型变量
    * 未装箱的值类型不在堆上分配,定义了该类型的一个实例的方法不在活动(方法return后 或者是超出其作用域),为它们分配的存储就会被释放(线程栈指针指向返回地址) 而不是等着垃圾回收
* 值类型的装箱与拆箱
  * 值类型比引用类型"轻",原因是它们不作为对象在托管堆中分配内存,不被垃圾回收,也不通过指针进行引用,但许多时候都需要获取对值类型实例的引用,比如将一个值类型实例Add到ArrayList数组中,Add需要获取一个Object参数,但是代码传递的是值类型,为了使代码正常工作,该值类型实例会自动转换成在堆中托管的对象,然后获取该对象的引用.这就是 **装箱** 操作
  * **注意:** 这不同于值类型作为字段嵌入引用类型的对象中,因为装箱相当于将值类型作为Object类型字段,而不再作为值类型字段.前者在对象中存储的是值类型的值,后者在对象中存储的是对"值类型"的引用
  * 对值类型实例进行装箱的过程:
    * 1.在托管堆中分配内存,分配的内存量是值类型各字段所需的内存量,还要加上托管堆上所有对象都需要的两个额外陈冠(类型对象指针和同步块索引)所需的内存量
    * 2.值类型的字段复制到新分配的堆内存
    * 3.返回对象地址,现在该地址是对象的引用,值类型成了引用类型
  * 如果要将集合类中已经装箱的值类型(现在是引用类型)复制给在线程栈中的值类型实例,这就要涉及到 **拆箱** 操作
  * 拆箱不是直接将装箱的过程倒回来,拆箱的代价比装箱低得多.拆箱其实就是获取指针的过程,该指针指向包含在一个对象中的原始值类型(数据字段),往往紧接着拆箱发生一次字段复制
  * 已装箱值类型实例在拆箱时:
    * 1.如果包含"对已装箱值类型实例的引用"的变量为null,抛出NullReferenceException异常
    * 2.如果引用的对象不是"所需值类型的已装箱实例",抛出InvalidCastException异常
  * 值类型应该是"不可变"(immutable),也就是说,我们不应该定义任何会修改实例字段的成员(值类型的字面值不是实例的字段值),也就是要将值类型的字段都标记为readonly.有个好消息是,FCL的核心值类型(Int32,Int64,Single,Double,String等以及所有枚举)都是"不可变"的,所以使用这些类型时不会发生古怪的事情
  * 对象的相等性与同一性:System.Object类型提供了名为Equals的虚方法,作用是在两个对象引用相同的对象时,返回true,假如实参引用不同对象,Euqals不肯定对象是否包含相同的值,就返回false.所以,对于Object的Equals方法的默认实现,它实现的实际是 **同一性** ,而非 **相等性**  由于其派生类可以重写Object的Equals方法,所以不能再用它测试同一性,为此Object也提供了静态方法ReferenceEquals专门检测同一性(不应当使用C#的==操作符,因为某个操作数的类型有可能重载==操作符赋予其不同于"同一性的"含义)
  * Equals方法在Object中的原型为:public virtual Boolean Equals(Object obj){...} System.ValueType(所有值类型的基类)就 **重写** 了Object的Equals方法,并进行了执行值的相等性检查(而不是同一性检查),它的内部实现过程:
    * 1.如果obj实参为null,返回false
    * 2.如果this和obj实参引用不同类型的对象,返回false
    * 3.针对类型定义的每个实例字段,都将this对象中的值与obj对象中的值进行比较(通过调用字段的Equals方法 相当于遍历两棵树??树的深度相当于继承的层次),任何字段不相等,就返回false
    * 4.返回true
  * 由于CLR的反射机制慢,定义自己的值类型时应当重写Equals方法来提供自己的实现,提高相等性比较的性能,重写Equals方法时,还需要重载==和!=操作符方法,实现这些操作符方法在内部调用类型安全的Equals
* 其它
  * FCL设计者认为,将任何对象的任何实例放到哈希表集合中,能带来很多好处.为此System.Object提供了虚方法GetHashCode,它能获取任意对象的Int32哈希码
  * dynamic基元类型 5.5章节 待深入

### 六、类型和成员基础
* 类型的各种成员
  * 类型的成员简介
    * **常量**: 常量是指出数据值恒定不变的符号,常量总与类型关联,不与类的实例关联.常量在逻辑上总是静态成员
    * **字段**: 字段表示只读或可读/可写的数据值,字段可以使静态的,这种字段是类型的一部分;字段也可以是非静态的(实例),这种字段是对象(实例)的一部分,强烈建议将字段声明为私有,防止类型或对象的状态被类型外部的代码破坏
    * **实例构造器**: 实例构造器是将新*对象*的实例字段初始化为良好初始状态的特殊方法
    * **类型构造器**: 类型构造器是将*类型*的静态字段初始化为良好初始状态的特殊方法
    * **方法**: 方法是更改或查询类型或对象状态的函数,作用于类型的方法称为静态方法;作用于对象的方法称为实例方法,方法通常要读写类型或对象的字段
    * **操作符重载**: 操作符重载本质也是方法,定义了当操作符作用于对象是,应该如何操作该对象.由于并不是所有的编程语言都支持操作符重载,所以操作符重载不是公共语言规范CLS的一部分
    * **转换操作符**: 转换操作符是定义如何隐式或显式将对象从一种类型转型为另一种类型的方法,不是CLS的一部分
    * **属性**: 属性允许用简单的,字段风格的语法设置或查询类型或对象的逻辑状态,同时保证状态不被破坏.作用于类型成为静态属性,作用于对象成为实例属性(本质是加了语法糖的方法?)
    * **事件**: 静态事件允许类型向一个或多个静态或实例方法发送通知.实例(非静态)事件允许对象向一个或多个静态或实例方法发送通知.引发事件通常是为了响应提供事件的类型或对象状态的改变. 事件包含两个方法,允许静态或实例方法登记或注销对该事件的关注.同时事件通常还用一个委托字段来维护已登记的方法集
    * **类型**: 类型可定义其他嵌套类型,通常用这个办法将大的复杂的类型分解成更小的构建单元来实现
  * 需要注意的一点是,上述成员在CLR的中间语言IL代码层面上讲均是用字段和方法来实现的,也就是它们均是为了简化常见编程模式而进行的抽象
  * 任何编程语言,所对应的编译器都能正确处理源代码,为上述每种成员生成元数据和IL代码,所有编程语言生成的元数据格式完全一致,这正是CLR成为公共语言运行时的原因.元数据是所有语言都生成和使用的公共信息,正是有了元数据,用一种语言写的代码才能无缝访问另一种语言写的代码
  * 源代码中定义的所成员都会使编译生成元数据,并且有的成员还会使编译器生成额外的成员和额外的元数据
* 类型的可见性
  * 类型的可见性一般指定为public或internal,public类型不仅对定义程序集中的所有代码可见,还对其他程序集的代码可见.internal类型则仅对定义程序集中的所有代码可见,对其它程序集中的代码不可见.定义类型的时候如果不显示指定可见性,C#编译器会自动指定为internal
  * 友元程序集:生成程序集时,可用System.Runtime.CompilerServices命名空间中的InternalsVisiableTo特性标明它认为是友元的其它程序集,该特性获取表示有缘程序集名称和公匙的字符串参数,友元程序集能够访问该程序集中所有的internal类型以及这些类型的internal成员
* 成员的可访问性
  * 定义类型的成员时,可指定成员的可访问性.在代码中引用成员时,成员的可访问性指出引用是否合法.CLR自己定义了一组可访问性的修饰符,但是编程语言在成员应用的可访问性上,都选择了自己的一组术语(关键字)以及相应的语法.例如CLR使用Assembly表明成员对同一程序集内的所有代码可见 而C#对应的术语是internal public internal protected private 详见c#
  * 在C#中 如果没有显式声明成员的可访问性,通常默认选择private(限制最大的)
  * CLR要求接口类型的所有成员都具有public可访问性,C#编译器知道这一点,因此禁止开发人员显式指定接口或成员的可访问性
* 静态类
  * 有一些永远不需要实例化的类,例如Console Math Environment和ThreadPool,这些类只有static成员,事实上这种类的唯一作用是组合一组相关的成员.在C#中 要用 **static** 关键字定义不可以实例化的类,该关键字只能用于类而不能用于结构(值类型),因为CLR总是允许值类型实例化
  * C#编译器对静态类进行了如下限制
    * 静态类必须直接从基类System.Object派生,从其它任何基类派生都没有意义
    * 静态类不能实现接口,因为只有使用类的实例时才可调用类的接口方法
    * 静态类只能定义静态成员(字段,方法,属性,事件) 任何实例成员都会导致编译器报错
    * 静态类不能违字段,方法参数,或局部变量使用,因为他们都代表了引用了实例的变量,这不被允许
  * 使用关键字static定义类,将导致C#编译器将该类标记为abstract和sealed 另外编译器不会在类型中生成实例构造器方法 因为使用IlDasm.exe反汇编工具
* 分部类,结构和接口
* 组件,多态和版本控制

### 七、常量和字段
* 常量
  * 如`public const short MaxValue = (short)0x7FFF; `
  * 常量是值从不发生变化的符号.定义常量符号时,它的值在 **编译** 时就确定了.确定后,编译器将常量的值保存到程序集元数据中,这意味着只能定义编译器识别的 **基元类型的常量** ,在C#中,Boolean,Char,Byte,SByte,Int16,Int32,UInt16,UInt32,Single,Double,String等基元类型可以定义常量.C#也循序定义非基元类型的常量变量,前提是把值设为null
  * 由于常量值从不变化,所以常量总是被视为 **类型定义** 的一部分,换言之,常量总被视为 **静态成员**,而不是实例成员,定义常量将导致创建元数据
  * 代码引用常量符号时,编译器在定义常量的程序集的元数据中查找该符号,提取常量的值,将值直接嵌入生成的IL代码中,所以运行时并 **不需要为常量分配任何内存**,而且不能获取常量的地址,不传递常量参数.因此只有确定一个符号的值从不变化才定义常量(MaxInt16定义为32767).
* 字段
  * 字段是一种 **数据成员**,其中容纳了一个值类型的实例或者对一个引用类型的引用
  * CLR支持类型(静态)字段和实例(非静态)字段,如果是类型字段,容纳字段数据所需的动态内存实在类型对象中分配的,而类型对象是在类型加载到一个AppDomain时创建的,即通常是引用了该类型的任何方法首次进行JIT编译的时候.如果是实例字段,容纳字段所需的动态内存实在构造类型的实例的时候分配
  * CLR支持readOnly字段和read/write字段,大多数字段(默认)都是read/write字段,这意味着在代码执行过程中,字段值可以多次改变.但readOnly字段只能在构造器方法中写入(构造器方法只能调用一次,即对象首次创建的时候).编译器和验证机制确保readOnly字段不会被构造器以外的任何方法写入,可以利用反射来修改readOnly字段
  * ```public static readonly Random s_random=new Random();```  
  在上述代码中,许多字段都是 **内敛(inline)初始化** 的.C#允许使用这种简便的内敛初始化语法来初始化类型常量,write/read字段,和readonly字段.这种方法 **本质上** 也是在构造器中对字段进行初始化,字段的内敛初始化只是一种语法上的简化.但是使用内敛语法而不是在构造器中赋值会有一些性能问题需要考虑
  * 当某个字段是引用类型,而且该字段被标记为readonly时,不可改变的是引用,而非字段引用的对象(就是不能再让该变量引用其它的对象了)


  |CLR术语|C#术语|说明
  |:-:|:-:|:-:
  |Static|static|这种字段是类型状态的一部分,不是对象状态的一部分
  |Instance|(默认)|这种字段与类型的一个实例关联.不是与类型本身关联
  |InitOnly|readonly|只读字段,这种字段只能由一个构造器方法中的代码写入
  |Volatile|volatile|(易变)编译器,CLR和硬件不会对访问这种字段的代码执行"线程不安全"的优化措施

### 八、方法
* 实例构造器和类(引用类型)
  * **构造器** 是将类型的实例初始化为良好状态的特殊方法.构造方法在"方法定义元数据表"中始终叫做.ctor(constructor的简称).创建引用类型的实例时,首先为实例的数据字段分配内存,然后初始化对象的附加字段(类型对象指针和同步块索引),最后调用类型的实例构造器来设置对象的初始状态.
  * 构造引用类型的对象时,在调用类型的实例构造器之前,为对象分配的内存总是先被 **归零**,没有被构造器显式初始化的所有字段都保证获得0或null值(VS验证 int被初始化成null 跟tm没初始化没啥区别)
  * 和其它方法不同,实例构造器永远不能被继承,也就是类只有类自己定义的构造器.如果类没有显式定义任何构造器.C#编译器将定义一个默认(无参)构造器.在它的实现中,只是简单地调用了基类的无参构造器.即默认如下构造器  
  `public SomeType():base(){}`  
  * 一个类型可以定义多个实例构造器,每个构造器都必须有不同的 **签名** 而且每个都可以有不同的"可访问性".为了使代码"可验证",类的实例构造器在访问从基类生成的任何字段之前,必须先调用基类的构造器.如果派生类的构造器没有显式调用一个基类构造器,C#编译器会自动生成对默认的基类构造器的调用.最终,System.Object的公共无参构造器会被调用,该构造器什么都不做直接返回
  * 静态类(static)在元数据中是抽象密封类(abstract&sealed)
  * C#提供了一种简化的语法,允许以  **内联**(其实就是嵌入)方式初始化实例字段,但在幕后,它会将这种语法转换成构造器方法中的代码来执行初始化,这提醒我们要注意代码的膨胀效应  
  * 编译器在为自定义的实例构造器方法生成(IL)代码时
    * 1.在方法的开始位置,会包含用于初始化内联字段的代码
    * 2.在这些初始化代码之后,编译器会插入对基类构造器的调用
    * 3.然后,编译器会插入构造器方法自己的代码
  * 如果有几个已内联初始化的实例字段和许多重载的构造器方法,可考虑不是在定义字段时内联初始化,而是创建单个构造器来执行这些公共的初始化,然后让其它构造都显式调用这个公共初始化构造器,这样能减少生成的代码.在C#中可以利用:this关键字显式调用另一个构造器  
  `public SomeType(Int32 x):this(){...}`  
  上面的重载构造器利用:this()显式调用了无参构造器SomeType()
* 实例构造器和结构(值类型)
  * 值类型(struct)构造器的工作方式与引用类型(class)构造器 **截然不同**.CLR总是允许创建值类型的实例,并且没有办法阻止值类型的实例化(因为只要声明了一个值类型实例 不需要new它的实例就已经创建了,内存已经分配了).所以值类型不需要定义构造器.C#编译器根本不会为值类型内联(嵌入)构造器
  * 但是CLR允许为值类型定义构造器,但必须显式调用才会执行,即需要用关键字new来显式调用实例构造器.并且C#编译器故意不允许值类型定义无参构造器,目的是为了防止开发人员对这种构造器什么时候调用产生迷惑.由于不能定义无参构造器,所以编译器永远不会生成自动调用它的代码,没有无参构造器,值类型的字段总是被初始化为0或null(VS验证:结构中的int被初始化为0,可以直接使用)
  * 因为C#编译器不允许为值类型定义无参构造器,所以不允许直接在声明字段处内联初始化,编译器会报错:结构中不能有实例字段初始值设定项
  * 注意:严格说 只有当值类型的字段嵌套到 **引用类型** 中时,才保证初始化为0或null, **基于栈** 的值类型字段则无此保证.为了确保代码的"可验证性",任何基于栈的值类型字段都必须在读取之前写入(赋值),确保不会在运行时因验证失败而抛出异常,否则无法通过编译,会报错"使用了未赋值的局部变量"(通过编译的条件是所有变量都要初始化,初始成null也算初始化过)
* 类型构造器
  * 除了实例构造器,CLR还支持 **类型构造器** ,也称 **静态构造器** , **类构造器** ,或者 **类型初始化器**.类型构造器可以应用于接口(虽然C#编译器不允许)、引用类型和值类型. 实例构造器的作用是设置类型的实例的初始状态,对应的,类型构造器的作用是设置类型的初始状态.类型默认没有定义类型构造器,并且开发人员最多定义一个类型构造器(不可重载,只有一个无参构造器),即类型构造器不能有参数
  * 类型构造器的几个特点
    * 如`static SomeType(){}`
    * 必须标记为static
    * 没有返回值
    * 不可以显式出现访问修饰符 因为C#编译器会自动把它们标记为private.之所以必须私有,是为了防止任何由开发人员写的代码调用它,对它的调用总是由CLR负责
    * 只能访问类型中的静态字段(而且它的常规用途就是初始化这些静态字段),同实例字段一样,静态字段也可以内联初始化.
  * 关于类型构造器的调用内部机制:  
  JIT编译器在编译一个方法时,会查看代码中引用了哪些类型,如果任何一个类型定义了类型构造器,JIT编译器会检查当前AppDomain是否已经执行了这个构造器,如果构造器从未执行,JIT编译器会在它生成的本机(naive)代码中添加对类型构造器的调用.如果类型构造器已经执行,JIT编译器就不添加对它的调用,因为它知道类型已经初始化好了.现在,当方法被JIT编译完毕后,线程开始执行它,最终会执行到调用类型构造器的代码,事实上,多个线程可能同时执行相同的方法.CLR希望确保在每个AppDomain中一个类型构造器只执行一次.为了保证这一点,在调用类型构造器时,调用线程需要获取一个**互斥线程同步锁**,这样一来,如果多个线程试图同时调用某个类型的静态构造器,只有一个线程才可以获得锁,其它线程会被阻塞(blocked).第一个线程会执行类型构造器的代码,当第一个线程离开构造器后,正在等待的线程被唤醒,然后发现类型构造器的代码已经被执行过,因此,这些线程不会在此执行代码,将直接从构造器方法返回.除此之外,如果再次调用这样的一个方法,CLR知道类型构造器已经被执行过,从而确保类型构造器不被再次调用.
  * 由于CLR保证一个类型构造器在每个AppDomain中只执行一次,而且这种执行是线程安全的,所以非常适合在类型构造器中初始化类型需要的任何 **单实例对象** (单例模式)
  * 不同于实例构造器,类型构造器在编译时不会自动插入调用基类的类型构造器,这种调用也是没有必要的,因为类型不可能有任何静态字段是从基类继承来的(静态字段只属于类型自己)  
  * 也就是编译器在为自定义的类型构造器方法生成(IL)代码时只有两步:
    * 1.在方法的开始位置,会包含用于初始化内联静态字段的代码
    * 2.然后,插入类型构造器方法自己的代码
  * 类型只有在AppDomain卸载时才会卸载,AppDomain卸载时,用于表示类型的对象(类型对象)将成为不可达的对象(不存在对它的引用),垃圾回收器会回收类型对象的内存
* 操作符重载方法
  * 有的语言允许类型定义操作符应该如何操作类型的实例.例如许多类型(System.String)都重载了相等(==)和不等(!=)操作符.但是,**CLR对操作符重载一无所知** 它甚至不知道什么是操作符。。。卧槽好犀利的见解.是编程语言定义了每个操作符的含义,以及当这些符号出现时,应该生成什么样的代码 例如在C#中,像基元类型应用+符号,编译器生成将两个数加到一起的代码,将+符号应用于String对象,C#编译器生成将两个字符串连接到一起的代码.
  * 虽然CLR对操作符一无所知,但是它规定了语言应当如何公开操作符重载,以便由另一种语言使用,每种编程语言都要自行决定是否使用操作符重载.如果决定支持,还要决定使用什么样的语法来表示和使用它们.
  * 需要注意的几点
    * CLR规范要求操作符重载方法必须是public和sealed方法.
    * 另外,C#(以及许多其它语言)都要求操作符重载方法至少有一个参数的类型与当前定义这个方法的类型相同(目的是使C#编译器能在合理的时间内找到要绑定的操作符方法)
    * C#代码示例:SomeType类重载加号操作符:  
    `public static SomeType operator+(SomeType s1,SomeType s2){return null;}`
  * 根据Microsoft的设计规范,重载了op_Addition方法的类型应定义一个公共的,名字更 **友好** 的Add方法,每个操作符都有推荐的相容与CLS的对应方法名 如上述示例代码应该像下面这样定义两个方法:  
  `public static SomeType operator+(SomeType s1,SomeType s2){return ...;}`  
  `public static SomeType Add(SomeType s1,SomeType s2){return s1+s2;}`
* 转换操作符方法
  * 本质是在类型的内部对类型转换操作的一级 **封装**
  * 有时需要将对象从一种类型转换为另一种类型(例如将Byte转换为Int32).当源类型和目标类型都是编译器识别的 **基元类型** 时,编译器自己就知道如何生成转换对象所需的代码(FCL已经写好了?)
  * 如果源类型或目标类型不是基元类型,编译器会生成代码要求CLR执行转换(强制转换).这种情况下,CLR只是检查源对象的类型和目标类型(或者从目标类型派生的其它类型)是否相同.但有时需要将一种类型转换成 **全然不同** 的其它类型.为了进行这样的转换,该类型应该定义只有一个参数的公共构造器,该参数是源类型的实例.还应该定义无参的公共实例方法Toxxx(类似于ToString),下面会有代码展示如何为SomeType类型正确定义 **转换构造器** 和方法
  * 转换操作符使将对象从一种类型转换为另一种类型的 **特殊方法** ,C#允许使用特殊的语法来定义转换操作符方法.CLR规范要求转换操作符重载方法必须是public和static方法.此外,还要求参数类型和返回类型二者之一必有其一与定义转换方法的类型相同(与操作符重载方法相似)   
    >public sealed class SomeType{  
    //无参构造器  
    public SomeType(){...}  
    //由Int32构造的SomeType  
    public SomeType(Int32 num){...}  
    //由Single构造的SomeType  
    public SomeType(Single num){...}  
    //将SomeType转换为Int32并返回该值 实例方法,无参  
    public Int32 ToInt32(){...}  
    //将SomeType转换为Single并返回该值 实例方法,无参  
    public Single ToSingle(){...}  
    /******上面的是传统方法,下面使用特殊的语法定义转换操作符方法*****/  
    //由一个Int32隐式构造并返回一个SomeType  
    public static implicit operator SomeType(Int32 num){return new SomeType(num);}  
    //由一个SomeType显式返回一个Single  
    public static explicit operator Single(SomeType st){return st.ToSingle();}  
  }

  * 在C#中,**implicit** 关键字告诉编译器隐式类型转换的时候调用此方法 **explicit** 关键字告诉编译器只有在发现了显式转型时,才调用方法
  * **注意,方法的签名不包括返回值** 只包括方法名和参数列表,不包括返回值,除了极少数语言如(IL汇编语言)支持通过返回类型区别多个方法的能力,在两个关键字之后,指定 **operation** 关键字告诉编译器该方法是一个 **转换操作符** .在operation之后,指定对象要转换成什么类型(返回值的位置),在圆括号内(参数位置),指定要从什么类型转换
  * C#编译器提供了对转换操作符的完全支持.如果检测到代码中正在使用某个类型的对象,而实际期望的是另一种类型的对象.编译器就会查找能执行这种转换的隐式操作符方法,并生成代码来调用该方法.如果编译器看到源代码是将对象从一种类型显式转换为另一种类型,就会查找能执行这种换换的隐式或显式操作符方法,如果能找到,编译器会生成IL代码来调用它,如果找不到,就报错并停止编译.
* 扩展方法
  * 将该方法的参数类型和调用该方法的类型 **相互关联** ,使彼此都能单向操作.在 **工厂设计模式** 中用处较大,可以实现即使不知道工厂类型的存在也可以调用工厂类型中的方法(通过该方法的参数类型)
  * **扩展方法** 的引入:  
  `StringBuilder sb=new StringBuilder("hello,my name is Jeff!");`对比下面两段代码的**表现力**  
  1.`Int32 index=StringBuilderExtensions.IndexOf(sb.Replace('.','!'),'!');`  
  2.`Int32 index=sb.Replace('.','!').IndexOf('!');`  
  毋庸置疑,站在开发人员的角度,第二种的表现力要更强.在第一种写法中,要获取一个StringBuilder中的某个字符的索引,必须先知道StringBuilderExtensionsde类的存在.它影响了我们对代码行为的理解.使用StringBuilderExtensions显得有些小题大做,使程序员无法 **专注于当前操作**.所以我们设想,如果StringBuilder类定义了自己的IndexOf方法就好了.由此,我们就很容易理解C#扩展方法的意义了.
  * 我们允许定义一个静态方法,并用实例方法的语法调用,只需在这个方法的第一个参数前添加 **this关键字** ,就可以使用该参数类型的实例直接调用此方法  
  `public static Int32 IndexOf(this StringBuilder sb,Char value){...}`  
  所以,我们可以推测出编译器调用方法的额外工作,当编译器看到以下代码:`Int32 index =sb.IndexOf('X');`时,首先检查StringBuilder类或者它的任何基类是否提供了获取单个Char参数,名为IndexOf的一个实例方法.如果是,就生成IL代码来调用它,如果没有找到匹配的实例方法,就继续检查是否有任何静态类定义了名为IndexOf的静态方法,方法第一个参数为StringBuilder,并且用this关键字标识
  * 还有一个问题是,程序员在只拿到StringBuilder类的前提下知道有这样一个IndexOf方法(并不在StringBuilder类中定义),可以操作StringBuilder对象呢?-------可以通过Microsoft visual studio的"智能感知"窗口,列出当前可用的实例方法,也会列出可作用于句点左侧表达式类型的扩展方法.现在我们可以轻松定义自己的方法来操作各种类型,其它程序员在使用这些类型的对象时,也能轻松地发现你的方法.
  * 规则和原则
    * C#只支持扩展方法,不支持扩展属性,扩展事件,扩展操作符等(尽管在CLR层面他们的本质也是方法)
    * 扩展方法必须在 **非泛型的静态类** 中声明,并且扩展方法只有第一个参数能用this关键字标记
    * 定义扩展方法的静态类本身需要有 **文件作用域**(即在命名空间中public或internal,不能够是嵌套类),因为C#编译器需要在静态类中查找扩展方法
    * 为增强性能并避免找到非你所愿的扩展方法,C#编译器要求在使用扩展方法的源代码中导入扩展方法所在类的命名空间(使用using指令)
    * 使用扩展方法这个功能须谨慎,在用一个扩展方法扩展一个类型时,同时也就扩展了其派生类型,所以,不要将System.Object作为扩展方法的第一个参数,否则这个方法在所有表达式类型上都能调用,造成"智能感知"被填充太多 **垃圾信息**
    * 版本控制问题是使用扩展方法必须谨慎的原因之一
* 分部方法

### 九、参数
* 可选参数和命名参数
  * 设计方法的参数时,可为部分或全部参数分配 **默认值**,那些方法本身已经提供默认值的参数称为 **可选参数**,没有提供默认值的参数称为 **必需参数**. 调用这些方法的代码可以选择不提供部分实参,使用其默认值.此外,调用方法时可通过 **指定参数名称** 来传递实参(没有指定顺序要求).  
  `private static void M(int a,Int32 x=9,String s="A",DateTime dt=default(DateTime)){...}`  
  `M();//全部使用默认值`  
  `M(3,dt:DateTime.Now)//指定DateTime参数`
  * 1.**命名参数**：调用方法时，可以不按位置传递参数，而是指定参数的命名来传值  
  2.**可选参数**：声明方法中的参数时，可以为其设置默认值，那么在调用该方法时，这种可选参数是可以忽略的
  * 规则和原则
    * 可为方法,构造器方法和有参属性(C#索引器)的参数指定默认值
    * 所有可选参数必须放在所有必需参数之后
    * 默认值必须是编译时能确定的常量值.
    * C#认定的基元类型,枚举类型,能设为null的任何引用类型,值类型都能设置默认值
    * 不要重命名变量,否则任何调用者如果以传参数名的方式传递实参,它们的代码也必须修改
    * 如果参数用 **ref** 或 **out** 关键字进行了标识,就不能设置默认值,因为没有办法为这些参数传递 **有意义** 的默认值
    * 可以按名称将实参传给没有默认值的参数,但所有必需参数都必须传递(无论按位置还是按名称),编译器才会编译代码
    * C#不允许省略逗号之间的实参,因为这会对可读性造成影响,如果想要省略有默认值的参数,可以以传参数名的方式传递实参
  * 一旦为参数分配了默认值,编译器就会在内部向该参数应用定制特性xxxxxxValueAttribute和OptionalAttribute.特性会中在最终生成的文件的元数据中持久性储存下来.之后,一旦编译器发现某个方法调用缺失了部分实参,就可以确定省略的是可选实参,并从元数据中提取默认值,将值嵌入调用中.
* 隐式类型的局部变量  
  用var(**隐式类型**)声明局部变量只是一种简化语法(**语法糖?**),它要求编译器根据表达式推断具体数据类型.编译后var会被编译成具体的类型.并且var关键字只能声明方法内部的局部变量
* 以 **传引用** 的方式向方法传递参数
  * CLR默认所有方法参数都 **传值** .  
  1.传递 **引用类型** 的对象时,参数本身就是对象的引用,对象引用(或者说指向对象的指针)被传给方法,但是注意:引用(或指针)本身是传值的,意味着方法能够通过作为参数的引用来修改对象  
  2.传递 **值类型** 的实例时,传给方法的是实例的一个 **副本** 意味着方法将获得它专用的一个值类型副本.调用者中的实例不受影响.所以正常传参下,方法不能够修改作为参数传递进来的值类型实例.
  * CLR允许以传引用而非传值的方式传递参数.C#用关键字 **out & ref** 支持这个功能.两个关键字都告诉C#编译器生成元数据来指明参数是传引用的.编译器将生成代码来传递参数的地址,而非参数本身.  
  应用场景:这主要方便 **修改** 值类型参数实例和 **更换** 引用类型参数实例(而不是 **操作**)
  * CLR不区分ref和out两个关键字,即无论使用哪个关键字,都会生成相同的IL代码.另外元数据也几乎完全一致,除了一个bit(用来记录声明方法时指定的是out还是ref).但是C#编译器是将这两个关键字区别对待的.对于ref关键字和out关键字的区别,后面有表格表示
  * 从IL和CLR角度看,out和ref是同一码事:都导致传递指向实例的一个指针.但是从编译器的角度看,二者是有区别的.根据是out还是ref,编译器会按照不同的标准来验证你写的代码是否正确.而且对于设定两种关键字(ref&out)来标识这一特性是有必要性的,C#语言的设计者认为调用者应该显式表明意图,只有这样,在call site(调用位置)哪里,才能清楚的知道被调用的方法是否需要对传递的变量值进行更改.另外,CLR允许根据使用的是out还是ref参数对方法进行重载,但是不允许两个重载方法只有out和ref的区别则不合法,因为两个签名的元数据形式完全相同


  |关键字|调用方法前是否需要初始化参数|读取参数的值|返回前写入参数的值
  |:-:|:-:|:-:|:-:
  |ref|必须|可以|可以
  |out|不必|不可以|必须

  * 向方法传递可变数量的参数
    * 方法有时需要获取 **可变数量** 的参数.例如System.String类型的一些方法允许连接任意数量的字符串.  
    * 应用 **params** 关键字与不应用的代码对比  
    1.`public static int Add(int[] values){...}`
    `Add(new int[]{1,2,3,4});`  
    2.`public static int Add(params int[] values)`
    `Add(1,2,3,4);`  
    1的用法可以通过编译并能够正确运行,但并不好看(直观).由于params关键字的存在,它可以告诉编译器向参数应用定制特性System.ParamArrayAttribute.编译器会先生成代码构造一个数组,填充它的元素(来容纳它的实参),再生成代码来调用所选的方法.
    * 注意,只有方法的最后一个参数才可以用params关键字标记.另外,这个参数只能标记一维数组(任意类型的).也可以为这个参数传递null值,或者传递包含零个元素的一个数组的引用.
* 参数和返回类型的设计规范
* 常量性
  * CLR不支持将方法或参数声明为常量

### 十、属性
* 无参属性
  * 许多类型都定义了能被获取或更改的 **状态信息**. 这种状态信息一般作为类型的 **字段成员** 实现.无参属性就是我们平时说的属性.面向对象设计和编程的重要原则之一就是数据封装,这意味着类型的字段永远不应该公开,否则会因为不恰当的使用字段而破坏对象的状态.还有其它几个原因促使我们封装对类型中的数据字段的访问
    * 有时需要访问字段来执行一些 **副作用**.
    * 缓解某些值或者推迟创建一些内部对象
    * 以线程安全的方式访问字段  
    所以强烈建议将所有字段都设为 **private**.
  * 要允许用户或类型获取或设置状态信息,就公开一个针对该用途的方法.数据字段封装带来了巨大的好处.另外,将Set标记为protected,就可以只允许派生类型修改值
  * CLR提供了属性机制,可以将属性想象成 **智能字段**,即背后有额外逻辑的字段.
  >public String Name{  
    get{return this.name;}  
    set{this.name=value;}//关键字value总指代新值  
  }

  * 属性的几个特点
    * 每个属性都有名称和类型(类型不能是void)
    * 属性不能重载 即不能定义名称相同,类型不同的两个属性
    * 定义属性时通常同时制定get和set两个方法,但是可以省略set定义只读属性.或省略get定义只写属性
    * 私有字段(private)通常称为 **支持字段**,经常利用属性的get和set操作类型中定义的私有字段,但get&set方法并非一定要访问支持字段
    * 编译器在你指定的属性名之前自动附加get_和set_ **前缀** 来生成方法名.C#内建了对属性的支持.C#编译器发现代码试图获取或设置属性时,实际会生成对上述自动生成的方法的调用
  * 关于 **自动实现的属性**(AIP)
    * 只为了封装一个支持字段而创建属性,C#提供了更简洁的语法,称为自动实现的属性(AIP)  
    `public String Name{get;set;}`  
    C#编译器会自动为你声明一个私有字段,该字段类的类型就是属性的类型.
    * AIP不太推荐使用,首先字段的声明语法可能包含初始化部分(内联语法),但是没有简单的语法初始化AIP.其次是AIP的支持字段名称由编译器决定,每次重新编译代码都可能更改这个名称(即支持字段名不是自己定义的),故不支持序列化和反序列化
    * 如果使用AIP,属性必然是可读和可写的(可以private set;),由于不知道编译器生成的支持字段到底是什么名字.所以任何时候代码只能用属性名访问属性
  * CLR via C#一书的作者并不喜欢使用属性,因为他认为属性使用起来和字段相似,但本质是方法 这造成大量误解(仁者见仁,智者见智):
    * 属性可以只读或只写,但字段访问总是可读和可写的(readonly字段仅在构造器中可写)
    * 属性方法可能抛出异常,字段访问永远不会
    * **重要**:属性不能作为out或ref参数传给方法,而字段可以
    * 连续多次调用,属性方法每次都可能返回不同的值,字段则每次都返回相同的值
    * 属性方法可能造成明显的副作用(访问属性时,除了单纯设置或获取属性,还会造成对象状态的改变),如果存在多个副作用,程序的行为就要依赖于历史(或者称为求值顺序).如果以不同的顺序设置属性,类型的每一次的行为都会不同,那么这是不合理的  
    * 他认为现在的程序员对属性的依赖过度,属性的唯一好处是提供了简化的语法,和调用普通方法相比,属性不仅不会提升代码的性能,还会妨碍对代码的理解.
  * 对象(和集合)初始化器
    * 经常要构造一个对象并设置对象的一些 **公共属性**(或 **公共字段**).为了简化这个常见编程模式,C#语言支持一种特殊的对象初始化语法. 如下面这个例子  
    `Employee e=new Employee(){Name="Jeff",age=45};`  
    这个语句做了好几件事情,包括构造一个Employee对象,为该对象的Name属性和age字段初始化.
    * 如果想调用的本来就是一个无参构造器,那么圆括号也可以省略  
    `Employee e=new Employee{Name="Jeff",age=45};`    
    * 我最开始觉得这种写法不如重载多个构造器更简洁,但是要了解到,对象初始化器的特殊语法对于使用 **匿名类型** 具有必要性的意义
  * 匿名类型
    * 利用C#的匿名类型功能,可以用很简洁的语法来自动声明不可变(immutable)的元组类型.简单来说,C#提供匿名类型这种简便语法,将一组 **只读属性** 封装到单个对象中,而无需首先 **显式** 定义一个类型  
    `var o1 = new {Name="Jeff",Year=1964};`  
    new关键字后并没有指定类型名称,类型名由编译器生成,而且并不会告诉编程人员该类型名称具体是什么(这正是匿名的含义),所以无法再源代码级使用匿名的类型名称.并且必须使用new关键字和 **对象初始化器** 语法来声明匿名类型的属性并将它们初始化.
    * 需要注意的一点是,匿名类型的对象必须由var声明,但使用var声明的对象不一定都是匿名对象.如`var n = 5;`,n是隐式类型化的局部变量.尽管这种用法在C#中很多人并不推荐使用.
    * 在上述使用匿名类型的代码中,C#编译器做了如下的工作  
    1.推断每个表达式的类型  
    2.创建推断类型的私有字段  
    3.为每个字段创建公共只读属性  
    4.创建一个构造器接受所有这些表达式
    5.重写Equals,GetHashCode,ToString三个方法
    * 匿名类型的属性是 **只读** 的,而并非可读可写,目的是防止对象的哈希码发生改变
    * 还有另一种语法来声明匿名类型和其中的属性(恐怕比第一种更要常用)
      >string Name = "Jeff";  
      int Year = 1964 ;  
      var o1 = new {Name,Year};

    * 如果编译器发现编程人员在源代码中定义了多个匿名类型,而且这些类型具有相同的结构(可以理解为 **签名**,每个属性都有相同的类型和名称),那么它只会创建一个匿名类型的定义,但是创建该类型的多个实例,我觉得这个设计是非常合乎情理的.
    * 匿名类型经常于LINQ(语言集成查询)配合使用,可以用LINQ执行查询,从而生成由一组对象构成的集合,这些对象都是相同的匿名类型
    * 匿名类型的实例不能泄露到方法外部.即:  
    1.方法原型不能接受匿名类型的参数,因为无法指定匿名类型  
    2.方法也不能返回对匿名类型的引用  
* 有参属性
  * 无参属性的get访问器方法不接受参数,因此称为无参属性.C#还支持 **有参属性** 它的get访问器方法接受一个或多个参数,set访问器方法接受两个或多个参数.C#将有参属性称为 **索引器**.
  * C#使用 **数组风格** 的语法来公开有参属性(索引器).可以将索引器看成是C#开发人员手动对[]操作符的重载.  
  `public bool this[int bitPos]{
  get{...} set{...}
  }`  
  public 返回值 this[参数类型1 参数1,...]{
  get{...}  set{...}
  }
  * 可以看出,set访问器和get访问器公用一组参数列表,这些参数(和返回类型)可以是除void之外的任意类型.和无参属性不同,类型可以提供多个重载的索引器,条件是这些索引器的签名不同.索引器的set访问器方法同样包含一个隐藏参数value,代表想赋给被索引元素的新值.
  * **重点理解**: CLR本身并不区分无参属性和有参属性(因为在运行时层面,只能区分字段和方法,在编译层面,才能够区分类型中的各种成员).对于CLR来说,每个属性都只是类型中定义的一对方法和一些元数据.只是C#开发团队选择this[...]作为表达索引器的语法.CLR以相同的方式对待有参和无参属性.我这样理解:属性这种成员本来就是C#开发团队作为简化(改进)编程模式而引入的,CLR对此并不知情. - -
  * 对于前面的索引器,在编译后,原始代码似乎是这样写的:  
  `public bool get_Item(int bitPos){...}`  
  `public void set_Item(int bitPos,bool value){...}`  
  编译器在索引器名称之前附加 **get_或者set前缀**.从而自动生成这些方法的名称.因为C#的索引器语法不允许开发人员指定索引器名称,所以C#开发团队为访问器方法选择了一个默认名称——Item.但是用C#编程永远看不到Item这个名称,所以无需关心编译器自动生成的什么名称
* 调用属性访问器方法的性能
  * 对于简单的get&set方法,JIT编译器会将代码 **内联**(inline,或者说嵌入).这样使用属性(而不是使用字段)就没有性能上的损失.所谓内联,就是将方法的代码直接编译到调用它的方法中,这就避免了在运行时发出调用所产生的开销,但是代价是编译好的方法会变得更大(用空间换时间的思想)
  * JIT编译器在调试代码时不会内联属性方法,因为内联的代码会变得难以调试.所以在程序的发行版本中,访问属性时的性能会更快.字段在调试和发布版本中速度都很快
* 属性访问器的可访问性  
   * 最常见的情形是提供公共get访问器和受保护的set访问器  
   >public class SomeType{  
   private string m_name;  
   public string Name{  
   get{return m_name;}  
   protected set{m_name=value;}  
 }  }

   * Name属性本身是public属性,意味着get访问器方法是公共的,所有代码都能调用.而set访问器方法声明为protected,只能从SomeType内部定义的代码中调用,或者从SomeType的派生类型的代码中调用
* 泛型属性访问器方法 (有待深入理解)
  * 属性不能引入它自己的泛型类型参数,最主要的原因是概念上说不通.属性本来应该表示可供查询或设置的某个对象特征.一旦引入泛型类型的参数,就意味着有可能改变查询/设置行为.**但是属性不应该和行为站边**.公开对象的行为,应该定义方法而非属性.

### 十一、事件  
*按照Microsoft的 **事件模式** 下面有很多约定的内容,实际上事件的使用更加灵活*
* 设计要公开事件的类型  
  1. 第一步:定义类型来容纳所有需要发送给事件通知接收者的附加信息  
    * 事件引发时,引发事件的对象可能希望接收事件通知的对象传递一些附加信息,这些附加信息需要封装到它自己的类中.该类通常包含一组私有只读字段,以及一些用于公开这些字段的只读公共属性.根据 **约定**,这种类应该从System.EventArgs派生,并且类名以EventArgs结束.下面将该类命名为NewMailEventArgs.它的各个字段包含了发件人(m_from),收件人(m_to),标题(m_subject)和内容(m_content).  
    * 注意: 事件模式要求委托定义和回调方法将派生自EventArgs的参数命名为e,这个要求的唯一作用就是加强事件模式的**一致性**.另外,事件模式要求所有事件处理方法的返回类型都是 **void** ,这很有必要,因为引发事件后可能调用好几个回调方法,但没有方法获得所有回调方法的返回值(如果将所有返回信息也封装到一个类型中?).
    * 理解:它们本可以分别作为委托的参数传递的,但是Microsoft提供了一种更清晰的 **事件模型**.  
    在FCL中定义了EventArgs类:  
    >public class EventArgs{  
    public static readonly EventArgs Empty = new EventArgs();  
    public EventArgs(){ }  }

    * 定义不用传递附加数据的事件时,可直接使用EventArgs.Empty,不用构造新的EventArgs对象,这是一个很好的**设计思想**    
   容纳所有应该发给事件接受者的附加信息的NewMailEventArgs:  
  >internal class NewMailEventArgs : EventArgs{  
  private readonly String m_from,m_to,m_subject,m_content;//私有只读字段  
  public NewMailEventArgs(String m_from,...){...}//公共只读属性  
  public String From{get{return m_from}}...  }

  2. 第二步,定义事件成员  
    * FCL在System命名空间下定义了泛型EventHander委托类型:  
    `public delegate void EventHander<TEventArgs>(Object Sender,TEventArgs e); `    
    * 这样设计的话,所有对应泛型EventHander委托类型的回调方法原型就必须是下面这种形式:  
    `void MethodName(Object Sender,NewMailEventArgs e){...};`NewMailEventArgs类型也可以是其它继承自EventArgas的类. 将Sender参数的类型定位Object的原因之一是灵活性,它使委托能由多个类型使用,只要类型提供了TEventArgs事件.
    * 也就是按照这种事件模式,本该作为参数传递的很多附加信息都应当封装到EventArgs的派生类中,然后和 **事件的发出者Sender** 和 **封装了所有的附加信息的对象** 作为两个参数传递给回调方法.
    * 事件是作为类的成员在类中声明的:  
    `public event EventHander<NewMailEventArgs> NewMail;`
  3. 第三步,定义负责引发事件的方法来通知事件的登记对象
    * 按照约定,引发事件的类(Sender)要定义一个 **受保护的虚方法**,如果是密封类,则定义为私有非虚方法.要想触发事件,就需要Sender或其派生类的代码调用该方法,方法一般只获取一个参数,即NewMainEventArgs对象(封装附加信息的类型的实例).方法的默认实现只是检查一下是否有对象登记了对事件的关注.  
    >internal class MailManager{  
    protected virtual void OnNewMail(NewMailEventArgs e){  
    EventHander<NewMailEventArgs temp = Volatile.Read(ref this.NewMail)  
    if(temp!=null)temp(this,e);  }}  

    * 出于 **线程安全** 的考虑,在引发事件前,要将对委托字段的引用复制到一个临时变量temp中,然后检查事件的登记对象是否为空,如不为空,则引发事件.不使用临时变量的问题在于,虽然线程检查出NewMail不为null,但就在调用NewMail之前,另一个线程有可能从委托链中移除一个委托,使NewMail成了null,但这时候第一个线程已经执行完了空指针检查,这会抛出NullReferenceException异常,为了修正这个 **竞态问题** ,有了如下这种写法:  
    `EventHander<NewMailEventArgs> temp= Volatile.Read(ref NewMail);
    if(temp!=null)temp(this,e);`  
    来替代原来的写法:  
    `if(NewMail!=null)NewMail(this,e);`
    * **代码复用思想**: 为方便起见,可以定义扩展方法(后缀Extensions)来封装这个线程安全逻辑:
    >public static class EventArgExtensions{  
    public static void Raise<TEventArgs(this TEventArgs e,Object sender,  
    ref EventHandler<TEventArgs eventDelagate){  
    EventHandler<TEventArgs temp=Volatile.Read(ref eventDelagate);  
    if(temp!=null)temp(sender,e);} }  
    但是貌似泛型扩展方法,导致任意类型都能用这个扩展方法,应该是合理的吧,因为任意类型都可以定义事件,然后使用这个事件模式就应当使用这个线程安全逻辑

  4. 第四步:定义方法将输入转化为期望事件
    * 类还必须有一个方法获取输入并转化为事件的引发,即在这个方法中,将事件的附加信息构造成对象,并作为参数传给负责引发事件的方法.
* 编译器实现事件成员的 **内部细节**
  * C#编译器在编译时将事件成员转换为 **3个构造**
    1. 一个被初始化为null的私有委托字段  
    2. 一个公共add_xxx方法(xxx是事件名)
    3. 一个公共remove_xxx方法(xxx是事件名)  
  * 第一个构造是具有恰当委托类型的字段,该字段是对一个委托列表的头部的引用.事件发生时会通知这个列表中的委托,字段初始化为null表明没有listener登记对该事件的关注.一个方法登记对事件的关注时,该字段引用事件委托类型的实例,然后该实例可能引用更多的委托实例.侦听者登记对事件的关注时,只需将委托类型的实例添加到该委托列表中,注销对事件的关注时意味着从列表中移除委托实例  
  注意: 该委托字段始终被定义为 **private**,目的是防止类外部的代码不正确的操纵它.
  * 第二个构造是一个方法,允许其它对象登记对事件的关注,C#编译器在事件名之前附加 **add_前缀** 并自动命名该方法.C#编译器还自动为方法生成代码,生成的代码总是调用System.Delegate的静态Combine方法(被重载为+=),它将委托实例添加到委托列表中,返回新的列表头
  * 第三个构造是一个方法,允许其它对象注销对事件的关注,C#编译器在事件名之前附加 **remove_前缀** 并自动命名该方法.方法中的代码总是调用System.Delegate的静态Remove方法(被重载为-=),将委托实例从列表中删除,返回新的列表头  
  * 注意:试图删除从未添加过的方法,Delegate的Remove方法在内部不做任何事情,也就是不会抛出任何异常,事件的方法集合保持不变.
  * add和remove方法以 **线程安全** 的一种模式更新值,该模式的详情见 Interlocked Anything模式
  * add和remove方法的可访问性与事件的可访问性一致,一般为public/protected,但无论如何,只有类型本身才能访问委托字段
  * 除了生成3个构造,编译器还会在托管程序集中生成一个事件定义记录项,这个记录项包含了一些标志(flag)和 **基础委托类型** (underlying delegate type).这些信息的作用很简单,就是建立"事件"的抽象概念和它的访问器方法之间的联系.而CLR并不使用这些信息.
* 设计侦听事件的类型(事件的观察者Listener)
  * 该类型应当包括下面几个部分
    1. 构造函数
    2. 登记对事件的关注的方法(public)
    3. 注销对事件的关注的方法(public)
    4. 回调方法(private)
  * C#可以使用 **+=** 操作符登记方法对事件的关注,如:  
  `mm.NewMail += FaxMsg;`(-=操作符注销关注同理.)  
  C#编译器内建了对事件的支持,会将+=操作符重载为下面的方法:  
  `mm.add_NewMail(new EventHandler<NewMailEventArgs>(this.FaxMsg));`  
  C#编译器生成的代码构造了一个委托对象,其中包装了Fax类的FaxMsg方法,接着C#编译器调用了自动生成的add_NewMail方法,向它传递新的委托对象.这种重载 **隐藏** 了内部的委托的实现细节,将方法直接登记到事件上.(可以用ILDasm.exe工具查看IL代码)
  * MailManager对象引发事件时,Fax对象的FaxMsg方法会被调用.调用这个方法时,会传递MailManager的实例作为它的第一个参数(即Sender),该参数大部分时候被忽略,但是如果Fax对象希望在相应事件时访问MailManager对象的成员,它就能派上用场了(但是既然如此,为什么不在引发事件之前,将MailManager对象的成员封装到NewMailEventArgs中呢?)第二个参数是NewMailEventArgs对象引用,对象中包含MailManager和NewMailEventArgs设计者认为对事件接受者(Fax)来说有用的附加信息.在此例中就是发件人,收件人,主题和内容.
  * ***这条对于unity游戏开发非常重要 !***  
  对象不再希望接收事件通知时,应 **注销** 对事件的关注. 对象只要向任一事件登记了它的一个方法,便永远不会被 **垃圾回收**,所以如果你的类型要实现IDisposable和Dispose方法,就应该在实现中注销对所有事件的关注.(也就是GameObject没有用之后,应该注销掉所有它的方法对事件的关注)
* 显式实现事件

### 十三、接口
* 类和接口实现
  * 关于 **多继承** 的概念,并不陌生.但是CLR不支持多继承,因此所有的托管编程语言都不支持多继承.但是CLR通过 **接口** 提供了"缩水版"的多继承.至于为什么C#的设计者决定不支持多继承,他们认为对于整个设计而言,多继承较之单根继承无法让开发者更轻易地掌控整个继承树,还会带入臃肿成员,成员的调用还可能会冲突而不安全.
  * CLR允许开发人员定义接口,它实际只是对一组方法签名进行了统一命名,这些方法不提供任何实现.类通过指定接口名称来 **实现接口**.而且 **必须显式实现** 接口的方法.CLR允许一个类实现多个接口
* 定义接口
  * 如前所述,接口对一组方法签名进行了统一命名.并且,接口还能定义事件、无参属性和有参属性(索引器).因为它们本质上都是方法,只是语法上的简化.不过接口不能定义任何构造器方法,也不能定义任何字段.
  * C#使用 **interface** 关键字定义接口,并且不能有访问权限修饰符.要为接口指定名称和一组实例方法签名(不能实现).FCL几个接口定义的例子:  
  >public interface IDisposable{  
  void Dispose();  
  }

  * 在CLR看来接口定义就是类型定义.也就是说,CLR会为接口 **类型对象** 定义内部数据结构,同时通过反射机制来查询接口类型的功能.和类型一样,接口可以在文件范围内定义,也可以嵌套在另一个类型中.定义接口时,可指定你希望的任何可访问性修饰符.
  * 根据 **约定**,接口类型名称以 **大写字母I** 开头.目的是方便在源代码中辨认接口类型.CLR支持泛型接口和接口中的泛型方法.
  * 接口定义可从另一个或多个接口 **"继承"** ,但是这不是严格的继承,接口的继承工作方式并不和类继承完全一样.应当将接口继承看成是将其它接口的协定包括到新接口中,意味着实现了继承自其它接口的接口的类,必须实现新接口的所有方法加上被继承接口的所有方法.
* 实现接口
  * C#编译器要求将实现接口的方法(简称 **接口方法** )标记为 **public**.CLR要求将接口方法标记为 **virtual**.
    * 如果不将方法显式标记为virtual,编译器会将它们标记为virtual和sealed,这会阻止派生类重写接口方法,但是派生类可以重新继承同一个接口并为接口方法提供自己的实现,但是既然这样,何不当初直接将基类的接口方法标记为virtual呢
    * 将方法显式标记为virtual,编译器会保持它的非密封状态,使派生类能够重写它.
    * 所以我觉得应当将所有的接口方法都标记为public virtual.
* 关于调用接口方法的更多探讨
  * CLR允许定义 **接口类型** 的字段,参数,或局部变量(这用法有点鬼畜...),使用接口类型的变量只可以调用该接口中定义的方法.此外还允许接口类型的变量调用Object定义的方法(貌似还有Type?),因为接口在CLR层面也是类型,类型最终必然继承自Object.如:  
  `String s="Jeff";`  
  `ICloneable cloneable=s;//string类实现了ICloneable接口`  
  `cloneable.Clone();//所以s只能调用ICloneable接口提供的Clone方法`
  * 值类型也特么可以实现接口,但是值类型的实例在转换为接口类型时必须 **装箱**.因为接口变量时引用,必须指向堆上的对象,使CLR能检查对象的类型对象指针从而确定对象的确切类型.调用已装箱值类型的接口方法时,CLR会跟随对象的类型对象指针找到类型对象的方法表,从而正确调用方法.
* 隐式和显式接口方法实现(的内部细节)
  * 类型加载到CLR中时,会为该类型创建并初始化一个方法表,在这个方法表中,类型引入的每个新方法都有对应的记录项,另外,还为类型继承的所有虚方法添加了记录项.继承的虚方法既有 **继承层次结构** 中的各个 **基类型** 定义的,也有 **接口类型** 定义的.对于下面有一个简单的类型定义:  
  >internal sealed class SimpleType:IDisposable{  
  public void Dispose(){Console.WriteLine("Dispose");}  
  }  
  新引入的Dispose()方法和IDisposable接口方法的签名完全一致,所以SimpleType方法表中的两个记录项引用 **同一个实现**.

  * 在上面的例子中,使用接口类型IDisposable变量调用接口方法和使用SimpleType类型变量调用这个方法看不出任何区别.但是如果将接口类型的名称作为接口方法的前缀(例如`IDisposable.Dispose`),就会创建 **显式接口方法实现**(**EIMI**). 它有几个特点:
    * C#不允许为EIMI指定可访问性,编译器生成方法的元数据时,它的可访问性会被 **自动设为private** ,防止其他代码在使用类的实例时直接调用接口方法,只有通过接口类型的变量才能调用接口方法
    * EIMI方法不能标记为virtual,所以不能被重写.这是由于EIMI方法并非真的是类型的对象模型的一部分,它只是将接口的一组行为(方法)和类型连接起来,同时避免公开行为/方法.(很难理解...)
* 泛型接口
  * 泛型接口有几个好处
    1. 泛型接口提供了出色的 **编译时类型安全性**. 有的接口(比如非泛型IComparable接口)定义的方法使用了Object参数或Object返回类型,在代码中调用这些接口方法时,可传递对任何类型的实例的引用.但这通常不是我们期望的.接口方法理想情况下应该使用 **强类型**.泛型接口提供了相应的实现方案,在 **编译层面** 报错更下安全
    2. 泛型接口在处理值类型时装箱次数会少很多.比如可以定义这样的接口:  
    `public interface<T> IXXX{ void XXX(T t);}`  
    这种实现比  
    `public interface IXXX{ void XXX(Object o);}`  
    安全得多,并且在使用值类型时,**不会发生装箱操作**.    
    `public SomeType:IXXX<int>{ public virtual XXX(int i){...} }`  
    对比下面的实现接口  
    `public SomeType:IXXX{public virtual XXX(Object o){...}}`
    3. 类可以实现同一个泛型接口若干次,只要每次使用不同的类型参数,想想 **多态(逻辑复用)**,同时保证了 **类型安全** ,贼厉害.  
    `public SomeType:IXXX<int>,IXXX<String>{`  
      `public virtual XXX(int i){...}`  
      `public virtual XXX(string s){...}`  
      `}`
  * 接口的泛型类型参数可以标记为逆变(in)和协边(out?),为泛型接口的使用提供了更大的灵活性.
* 泛型和接口约束
  * 可以 **将泛型类型参数参数为接口**,这将带来很多好处.
  * 第一个好处在于,可以将泛型类型参数约束为多个接口,这样一来,传递的参数的类型必须实现全部接口约束.(使用 **where关键字** )如:  
  `private static int M<T>(T t) Where T : IComparable,IConvertible{...} `  
  如果只需要一个接口约束,可以将参数的类型设为该接口(就不需要使用泛型了),此时实参可以是任意类型,只要这个类型实现了该接口.如:  
  `private static int M(IComparable t){...}`但是如果传递的参数是值类型,这种写法会导致 **值类型装箱**,影响性能,还影响理解,所以 **不推荐使用**.
  * 我们知道在C#中,定义方法参数时,参数的类型规定了传递的实参必须是该类型或者它的派生类.如果参数的类型是接口,那么实参可以使任意实现了该接口的类型.如果需要多个接口约束,那么就要像上上面那样使用泛型和where关键字了.
  * 然后如果将泛型类型参数T约束为一个类加上一些接口,就表示要传递的实参类型必须是指定类或者其派生类同时还要实现所有指定接口.这种 **灵活性** 使方法能细致地约束调用者能传递的内容,如果不满足这些约束,则产生编译错误.
  * C#编译器为接口约束生成特殊IL指令,导致直接在值类型上调用接口方法而不装箱.
* 实现多个具有相同方法名和签名的接口
  * 定义实现多个接口的类型时,这些接口可能定义了具有相同名称和签名的方法,这时必须使用"显式接口方法实现"来实现这个类型的成员.告诉编译器每个接口方法对应的是哪个接口的实现.并且在使用该类型的对象时,必须将其转换为相应的接口类型对象才能调用所需的方法.  
  (尽量不要出现这种情况,这种代码的可读性并不好)
* 用显式接口方法实现来增强编译时类型安全性
* 谨慎使用显式接口方法实现
  * EIMI有以下问题
    * VS无法智能感知
    * 值类型实例在转换成接口时装箱
    * EIMI不能由派生类调用
  * 幸好泛型接口可以帮助我们在大多数时候避免使用EIMI
* **设计**:基类还是接口(重要设计思想)
  * *IS-A* 对比 *CAN-DO* 关系  
  类型只能继承一个实现.如果派生类型和基类型建立不起IS-A关系,就不用基类而用接口.接口意味着CAN-DO关系.如果多种对象类型都 **"能"** 做某事,就位为它们创建接口
  * 易用性  
  对于开发人员,定义从基类派生的新类型通常比实现接口的所有方法容易得多,基类型可以提供大量功能,所以派生类型可能只需要稍作改动.而提供接口的话,新类型必须实现所有成员
  * 一致性实现  
  无论接口协定(contract)订立得多好,都无法保证完全正确的实现它.而如果基类型提供良好的 **默认实现**,那么派生出的类型一开始就是能正常工作并经过良好测试的类型,只需要根据需求修改虚方法.
  * 版本控制  
  向基类添加一个方法,派生类型将继承新方法,一开始使用的就是一个能正常工作的类型.而向接口添加新成员,会强迫接口的继承者更改其源代码并重新编译.






---

* 关于dll
  * DLL(Dynamic Link Library)文件即动态链接库文件，又称为"应用程序扩展" 在Windows中许多应用程序不是完整的可执行文件而是被分割成一些相对独立的动态链接库，当我们执行某一个程序时相应的dll文件会被调用。使用DLL的好处是不需要再运行之初加载(编译？)所有代码，只有在程序需要调用某个函数时才从dll中取出，使程序实现模块化，只有模块在相应功能被请求时才加载。对于实现 **更新** 意义重大，把某些逻辑代码放到dll中，需要改变某些功能时无需重新生成或安装整个程序，只需要更新DLL就能实现更新
