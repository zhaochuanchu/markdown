# c\#相关

* 关于属性
  * public string CarName002{get;set;}
  属性简写(语法糖)不能加入复杂逻辑 并且简写后和内部的同名字段(大小写)不再有对应关系
  * 可以使用private set;使之对外界只读，对内部可写
  * 属性相当于对字段的一级封装，本质是CLR内部生成的辅助字段
  * ctrl+r+e 快速生成字段对应的属性
  * 抽象属性 一般只读，由字段的变化而变化，如面积属性
* 命名风格:
  * pascal风格 MyName 类名 属性 方法 接口 事件 枚举 命名空间
  * camel风格 myName  字段名 参数名 变量名
* 类及类型成员修饰符
  * 注意 **类** 前面没有修饰符默认internal修饰, **类型** 成员前面没有修饰符默认private修饰
  * public 任何地方该类(成员)都可以被访问到
  * internal 只有在同一程序集内该类才可以被访问到
  * protected 只有在该类(或其派生类)内部可以被访问，即其可被继承
  * private 只有在该类本身内部可以被访问
* sealed(密封) 防止其它类继承此类 修饰方法时刻防止派生类重写此方法
* abstract(抽象)修饰符
  * 可以用来修饰类，方法，属性，索引器，事件
  * 修饰类时:表示这个类只能是其它类的基类，且该类不能被实例化
  * 修饰方法时:没有方法体,即签名的后面没有大括号,并且抽象方法只允许在抽象类中声明，必须在子类中重写(强制派生类覆盖) 并且子类中重写的方法要用override修饰符修饰
* virtual(虚)修饰符
  * 允许子类对父类的此方法进行重写
  * 可以用来修饰方法，属性，所引起，事件
  * 修饰方法时，被称作虚方法，不强制派生类覆盖。而和普通方法无法，子类中用new关键字修饰的方法，是区别于其父类的同名方法，并不是重写，并不推荐
* is和as操作符来转型
  * is检查对象是否兼容于指定类型(所谓兼容 即指定类型为该对象的 *实际* 类型或其 **基类**  可以安全的直接进行显式转换) 返回Boolean值true或false 如果对象引用null则总是返回false 所以is永远不会抛出异常 通常用作类型转换前的判断条件
  if(o is String){ String s=(String)o; print("ok");}
  * as操作符检查对象类型的兼容性并返回转换结果,如果不兼容则回null 永远不会抛出异常 as操作符简化is使用情况下代码的写法使其比is少执行一次兼容性检查,性能高一点点
  String s=o as String;if(s!=null){ok;}else{wrong;}


---
# .NET/CLR相关

### 一、CLR执行模型
* CIL,托管模块(代码),JIT,跨语言特性
  * IL是.NET框架中中间语言（Intermediate Language）的缩写 有时也称为CIL通用中间语言(Common Intermediate Language) 　　　它是 **基于栈** 的
  * CLR实际上是提供了一项使用了虚拟机技术的产品，他在操作系统之上，并不要求程序的运行平台是 Windows系统，只要是能够支持它的运行库的系统，都可以在上面运行.NET应用。所以，一个完全由托管代码组成的应用程序，只要编译一次，就可以在任何支持.NET的平台上运行.（从Mono的出现变得更加真实啦,不用再羡慕JAVA啦）
  * 程序集的文件负责封装中间语言，由一个或多个托管模块和资源文件组成。托管模块主要包括(**元(托管)数据** 和 **IL** ),托管模块即托管PE文件(由PE32(+)头、CLR头、元数据以及IL)。如果源代码由c#语言编写，那么需要使用c#的面向 **CLR** 的编译器(而不是本机代码编译器)编译生成托管代码。由CLR管理它的执行
  * 源代码编译成托管代码(即中间语言IL)，而不是能够直接在本地运行的原生机器码。托管代码在公共语言运行时(CLR)中运行，优势是公共语言运行时为托管代码提供多种服务，如加载和验证程序集确保代码只进行类型安全的操作。当某些方法第一次被调用时，CLR把具体的托管代码方法编译成适合本地运行的机器码(不同平台有所差异如X86 X64 ARM等)并将其缓存，以备下次调用时使用。这个过程就是 **即时编译**(JIT编译 Just In Time) JIT编译造成的性能损失只是一次性的所以并不显著。
  * 所以.NET平台上的程序实际上是被 **托管** 在CLR中，随着程序集的运行，公共语言运行时会持续提供各种服务，如内存管理，安全管理，线程管理等。托管代码可以调用CLR的运行时服务和功能，如GC，类型检查，安全支持等等。这些服务和功能都是 **独立** 于开发语言的统一的Managed Code行为
    `相对应CLR编译器`             `JIT即时编译器`
  c#/vb等源代码————————>IL托管代码——————————>本机CPU指令
  * 通用类型系统:CTS(Common Type System)描述类型的定义和行为的正式的规范,称作CTS规范
  * 公共语言规范:CLS(Common Language Specification) 定义了所有语言都必须支持的 **最小** 功能。提炼CLS的规则即:在CLR中，类型的每个成员要么是字段，要么是方法。这意味着每种面向CLR的编程语言都必须能访问字段和调用方法~~同时为了简化编程，语言往往提供了额外的 *抽象* 从而对这些常见的编程模式进行简化。例如 语言会公开枚举,数组,属性,索引器,委托,事件,构造器,终结器,操作符重载,转化操作符等概念。编译器在源代码中遇到其中的 **任何一样**,都必须将其转换成字段和方法使CLR和其它任何编程语言能够访问这些构造
  * 每个类编译之后都会得到一个憨厚大量字段和方法的一个类型，可以使用反汇编工具ILDasm.exe查看生成的托管模块,在《CLR via c#》的27页列举了常见的编程语言构造与CLR字段/方法的映射关系
  * 编程人员选择的语言会采用其熟悉的方式公开它自己的语言语法与类型规则，通过编译生成程序集时，它会将语言特有的语法 **映射** 到IL——也就是CLR的“语言”，使用的语言不同，用于定义类型的语法也不同，但是无论使用哪种语言，类型的行为都完全一致

### 四、类型机制
* 所有类型都从System.Object派生
  * System.Object的公共方法Equals GetHashCode ToString GetType 保护方法MemberwiseClone Finalize
  * Equals:如果两个对象具有相同的值返回true
  * GetHashCode:返回对象的值的哈希码
  * ToString:经常重写该方法来返回包含对象状态表示的String对象 例如核心类型Boolean和Int32重写该方法返回他们的值的字符串表示
  * GetType:指出调用GetType的对象是什么类型 返回的Type对象可以和反射类配合获取与对象的类型有关的元数据信息 需要指出的是此方法是非虚方法防止派生类重写该方法隐瞒其类型破坏类型的安全性
  * MemberwiseClone:非虚方法，创建类型的新实例返回其引用
  * Fianlize:在GC判断对象应该作为垃圾被回收之后,在对象的内存被实际回收之前调用此虚方法(类似析构函数)
* new操作符所做的事情:
  * 1.计算类型以及所有基类型中定义的所有实例字段所需要的字节数(包括额外成员如类型对象指针同步快索引 CLR利用额外成员管理对象)
  * 2.从托管堆分配类型要求的字节数从而分配对象的内存,同时分配的所有字节都设为 **0**
  * 3.初始化对象的类型对象指针和同步块索引
  * 4.调用类型的实例构造器(在c#中即构造函数)并传递new调用中指定的实参.
  * CLR要求所有对象都用new操作符创建
  * new执行了所有的这些操作之后返回指向新对象的一个引用
  * 需要指出没有和new操作符对应的delete操作符 即在CLR中没有办法显式的释放为对象分配的内存而采用垃圾回收机制
* 类型转换
  * CLR的最重要的特性之一:类型安全 在运行时CLR总是知道对象的类型是什么 同时调用GetType即可知道对象的 **确切类型**
  * CLR允许将对象转换为它的(实际)类型或它的任何基类型
  * C#不要求任何特殊语法即可将对象转换为它的任何基类型,因为这被认为是一种安全的隐式转换 但是将对象转换为它的某个派生类型时,c#要求开发人员只能进行显示转换(有风险可能会抛出异常)
  * 如果转换后的类型既不是其基类型或原类型,则CLR会禁止此转型并抛出InvalidCastException异常(因为如果CLR允许这样的转型 就毫无类型安全性可言了.将出现难以预料的结果)**运行时抛出异常以防止使用错误的类型数据**
  * 值类型和引用类型的转换成为装箱(boxing)或拆箱(unboxing)
  * c#中基本类型可以使用Convert类实现类型转换
  * 使用GetType可以取得任何对象的精确类型
  * 转型时常用 as操作符
* 命名空间
  * 命名空间对相关的类型进行逻辑分组,开发人员可以通过命名空间方便的定位类型
  * 为了使用一种简单的方式直接引用命名空间中的类型(省去打很长很麻烦的前缀)c#编译器通过using指令提供这个机制
  * 对于编译器,命名空间的作用就是 **为类型名称附加以句点为分割的符号而使名称变得更长,更可能具有唯一性**
  * C#的using指令是可选的,如果愿意完全可以输入类型的完全限定名称.**C#的using指令编译器尝试为类型名称附加不同的前缀,直至找到匹配项**
  * CLR对命名空间一无所知,访问类型时CLR需要知道类型的完整名称(可能是相当长的包含句点符号的名称)以及该类型的定义具体在哪个程序集中
  * 若存在同名的类型,为了消除歧义,引用时需要使用完全限定名称区分它们,否则c#编译器会报告错误消息指明这是"不明确的引用"
  * 如果只想使用命名空间的少量类型而不像让它的所有类型都跑出来 **污染** 全局命名空间,可以使用using指令的另一种形式为类型或命名空间创建别名
  如using WintellectWidget = Wintellect.Widget;
  所以要在库中设计由第三方使用的类型 应该在专门的命名空间中定义这些类型 这样编译器可以轻松消除这些歧义
  * 创建命名空间很简单,以C#为例                           
        namespace CompanyName{
          public sealed class A{ //TypeDef:CompanyName.A
          }
          namespace X{
            public class B{//TypeDef:CompanyName.X.B
            }
          }
        }
    右侧TypeDef注释是编译器在类型定义元数据表中添加的实际类型名称 这是CLR看到的类型名称
  * 命名空间可以极大减少打字 还能增强代码可读性  
* 类型,对象,线程栈,托管堆在运行时的相互关系
  * windows进程可能有多个线程,线程创建时会分配1MB的栈,栈空间用于向方法传递实参,同时也用来存放方法内部定义的局部变量
  * 调用方法前会将"返回地址"压入线程栈,方法抵达其return语句时,造成CPU的指令指针被设置成栈中的"返回地址",被调用方法的栈帧展开(unwind),恢复调用前的样子
  * JIT编译器将方法的IL代码转换成本机CPU指令时会注意到方法内部引用的所有类型,包括Int32,String,Employee等类型,当CLR确认了定义这些类型的程序集都已加载然后利用程序集的元数据提取与这些类型有关的信息,**在堆上** 创建一种数据结构开辟一块空间表示 **类型本身**(而不是类的对象),称之为 **类型对象** (区别于实例对象) .堆上的类型对象上的数据包括
    * *类型对象指针*
    * *同步块索引*
    * *静态字段:* 为类的静态字段提供支援的字节在类型对象自身中分配
    * *方法表:* 类型定义的每个方法都有对应的记录项
    当CLR确认方法需要的所有类型对象都已创建,待执行方法已经编译后,就允许线程执行方法的本机代码 CLR会自动将所有的局部变量初始化为 **null或0**　如果代码视图访问尚未显式初始化的局部变量,C#会报错:使用未赋值的局部变量
  * 托管堆上所有对象都包含两个额外成员:类型对象指针(type object pointer)和同步块索引(sync block index)
    * 类型对象指针: 任何时候在托管堆上新建对象,CLR都自动初始化实例对象内部的"类型对象指针"成员用来引用和对象相应的类型对象
    * 同步块索引: 待深入学习
  * 使用new操作符时,会在托管堆上创建一个实例对象(分配内存操作),实例对象上的数据包括:
    * 类型对象指针
    * 同步块索引
    * 实例数据字段以及容纳任何基类定义的所有实例字段
  * 类型对象同样包含类型对象指针成员,因为类型对象其本身也是对象,CLR创建类型对象的时候也会初始化这些成员.CLR开始在一个进程中运行时会立即(在托管堆中?)为MSCorLib.dll中定义的System.Type类型创建一个特殊的类型对象,其它类型对象都是该类型的实例,因此它们的类型对象指针成员会初始化成对System.Type类型对象的引用,然后System.Type在托管堆中同样也有类型对象指针,它指向它本身
  * System.Object.GetType方法返回存储在指定对象的类型对象指针成员中的地址,这样就可以判断系统中任何对象(包括类型对象本身)的真实类型
* CLR调用静态方法,非虚实例方法,虚实例方法的区别
  * 调用静态方法时: CLR会定位与定义静态方法的类型对应的类型对象,然后JIT编译器在类型对象的方法表中查找与被调用方法对应的记录项,对方法进行JIT编译(如果是第一次调用的话) 再调用JIT编译好的本机代码
  * 调用非虚实例方法时: JIT编译器会找到与发出调用的那个变量的类型在托管堆上对应的类型对象,如果再该类型对象中没有定义待调用的方法,JIT编译器会回溯类层次结构(一直回溯到Object)并在沿途的每个类型中查找该方法对应的记录项,因为每个类型对象都有一个字段引用了它的基类型
  * 调用虚实例方法时 与调用非虚实例方法类似,只是最后执行的是派生类重写的版本

### 五、基元类型,引用类型和值类型
* 基元类型
  * 使用System.Int32 a=new System.Int32();这种语法声明并初始化整数太繁琐,使用int a=0;增强了代码可读性,生成的IL代码与System.Int32生成的完全一致,编译器直接支持这样的数据类型成为 **基元类型** ,基元类型直接映射到Framework类库(FCL)中存在的类型
  * C#编译器非常熟悉基元类型,在编译代码时使用自己的特殊规则,支持与类型转换,字面值以及操作符有关的模式.编译器能够实现基元类型之间的隐式或显示转型(**尽管他们之间并没有派生关系**) 当转换被认为是"安全"(即不丢失数据精度或数量级)的时候,C#编译器才允许隐式转型,"不安全"的转型被要求使用显式转型 不同的编译器有可能生成不同的代码来处理这些转型.
  * 对基元类型执行运算时可能造成溢出,不同语言处理溢出的方式不同.C/C++不将溢出视为错误并允许值回滚,VB总将溢出视为错误并抛出异常 CLR提供了一些特殊的IL指令允许编译器选择它认为最恰当的行为,C#允许程序员自己决定如何处理溢出,溢出检查 **默认关闭** 可以使用/checked+编译器开关全局地打开或关闭溢出检车,c#也可以通过checked和unchecked操作符在代码的特定区域控制溢出检查 checked语句(操作符)唯一的作用是决定生成哪个版本的加减乘和数据转换的IL指令 不会对调用的方法造成任何影响
  * 作者对使用基元类型的几点建议:
    * 建议开发人员使用FCL类型名称 考虑到需要深层次理解其本质的原因
    * 尽量使用有符号数值类型,可以有效减少需要进行的强制类型转换,使代码更整洁容易维护, 并且, 无符号数值类型不符合CLS
    * 如果代码可能发生不希望的溢出(可能是因为无效的输入) 就把这些代码放到checked块中,同时捕捉OverFlowException得体地从错误中恢复
    * 在开发应用程序时,可以打开编译器的/checked+开关进行调试性生成,这样系统会对没有显式编辑checked的代码进行溢出检查,所以应用程序会运行起来慢一些,但是此时发生异常可以轻松检测到并及时修正代码中的bug;在正式发布应用程序时,应当使用编译器的/checked-开关,确保代码更快运行而不会产生溢出异常
  * C#基元类型与对应的FCL类型


  | C#基元类型|FCL类型|说明|
  | ------------- |:-------------:| -----:|
  | sbyte | System.SByte |有符号8位值|
  | byte  | System.Byte  |无符号8位值|
  | short | System.Int16 |有符号16位值|
  | ushort | System.UInt16 |无符号16位值|
  | int | System.Int32 |有符号32位值|
  | uint | System.UInt32 |无符号32位值|
  | long | System.Int64 |有符号64位值|
  | ulong | System.UInt64 |无符号64位值|
  | char | System.Char |16位Unicode字符|
  | float | System.Single |IEEE32位浮点值|
  | double | System.Double |IEEE64位浮点值|
  | bool | System.Boolean |true/false值|
  | string | System.String |字符数组|
  | object | System.Object |所有类型的基类型|

  从另一个角度来看,可以认为C#编译器自动假定所有源代码文件都添加了类似 using int=System.Int32;的using指令
* 引用类型和值类型
  * CLR支持两种类型,**引用类型**和**值类型** FCL中的大多数类型是引用类型,但程序员用的最多的是值类型
  * 引用类型从托管堆中分配 C#的new操作符返回对象内存地址
  * 关于引用类型的性能问题 认清下述事实
    * 内存必须从托管堆分配
    * 堆上分配的每个对象都有一些额外成员(类型对象指针和同步块索引?),这些成员必须初始化
    * 对象中的其他字节(为字段开辟的内存空间)总是设为**零**
    * 从托管堆分配对象时,可能强制执行一次垃圾回收(在内存不足的时候?)
  * 引用类型会使应用程序的性能下降,为了提升简单和常用的类型的性能,CLR提供了名为 **值类型** 的轻量级类型,值类型的实例在线程栈上分配(虽然也可作为字段嵌入引用类型的对象中)代表值类型的变量不包含只想实例的指针,而直接代表实例本身的字段.所以操作实例的字段不需要 **提领指针** ,并且值类型的实例不受垃圾回收器的控制.值类型的使用缓解了托管堆的压力,减少了用用程序生存期内的垃圾回收次数
  * 任何称为"类"(**class**)的类型为引用类型,所有结构(**struct**)或枚举(**enum**)都是值类型 根据定义,所有值类型都由Syste.ValueType派生: 所有结构类型都是System.ValueType的直接派生类,System.ValueType又直接从System.Object派生.所有枚举都由System.Enum抽象类型派生,而System.Enum又从System.ValueType派生.同时 在托管环境中CLR给予枚举类型特殊待遇,将其视为一等公民并提供各种强大的操作
  * 所有值类型都隐式密封,目的是防止将值类型用作其它类型的基类型,我们无法将Boolean,Char,Int32,Single,Double(这些基元类型都是结构体)等作为基类型来定义任何类型
  * 在非托管C/C++声明类型时,使用该类型的代码会决定在线程栈上还是在应用程序的堆上分配类型实例,但是在托管代码中,要由定义类型的开发人员决定在什么地方分配类型实例(如果定义的是值类型分配在线程栈中,若是引用类型分配在托管堆重) 使用类型的人对此无控制权
  * 一般情况下 我们很少使用自定义的结构(非FCL中提供的) 除非满足下列条件,否则不应声明为值类型
    * 类型具有基元类型的行为,是十分简单的类型
    * 类型不需要从其它任何类型继承
    * 类型也不派生出其它任何类型
    * 类型的实例较小(小于16字节)
    * 类型的实例较大(大于16字节) 但是不作为方法实参传递也不从方法返回
  * 值类型和引用类型的一些区别
    * 值类型对象有两种表示形式,**未装箱** 和 **已装箱** ,相反,引用类型总是处于 **已装箱** 形式
    * System.ValueType重写了Equals方法,在两个对象的字段值完全匹配的前提下返回true
    * 值类型中不能引入任何虚方法,所有方法都是不可抽象的,都是隐式密封(不可重写)的
    * 将值类型变量赋给另一个值类型变量,会进行逐字段的复制;将引用类型的变量赋给另一个引用类型变量只复制内存地址,所以赋值之后两个引用类型变量会引用堆中同一个对象,对一个变量执行的操作会影响到另一个变量.相反,值类型变量自成一体,对值类型变量执行的操作不可能影响其它值类型变量
    * 未装箱的值类型不在堆上分配,定义了该类型的一个实例的方法不在活动(方法return后 或者是超出其作用域),为它们分配的存储就会被释放(线程栈指针指向返回地址) 而不是等着垃圾回收
* 值类型的装箱与拆箱
  * 值类型比引用类型"轻",原因是它们不作为对象在托管堆中分配内存,不被垃圾回收,也不通过指针进行引用,但许多时候都需要获取对值类型实例的引用,比如将一个值类型实例Add到ArrayList数组中,Add需要获取一个Object参数,但是代码传递的是值类型,为了使代码正常工作,该值类型实例会自动转换成在堆中托管的对象,然后获取该对象的引用.这就是 **装箱** 操作
  * **注意:** 这不同于值类型作为字段嵌入引用类型的对象中,因为装箱相当于将值类型作为Object类型字段,而不再作为值类型字段.前者在对象中存储的是值类型的值,后者在对象中存储的是对"值类型"的引用
  * 对值类型实例进行装箱的过程:
    * 1.在托管堆中分配内存,分配的内存量是值类型各字段所需的内存量,还要加上托管堆上所有对象都需要的两个额外陈冠(类型对象指针和同步块索引)所需的内存量
    * 2.值类型的字段复制到新分配的堆内存
    * 3.返回对象地址,现在该地址是对象的引用,值类型成了引用类型
  * 如果要将集合类中已经装箱的值类型(现在是引用类型)复制给在线程栈中的值类型实例,这就要涉及到 **拆箱** 操作
  * 拆箱不是直接将装箱的过程倒回来,拆箱的代价比装箱低得多.拆箱其实就是获取指针的过程,该指针指向包含在一个对象中的原始值类型(数据字段),往往紧接着拆箱发生一次字段复制
  * 已装箱值类型实例在拆箱时:
    * 1.如果包含"对已装箱值类型实例的引用"的变量为null,抛出NullReferenceException异常
    * 2.如果引用的对象不是"所需值类型的已装箱实例",抛出InvalidCastException异常
  * 值类型应该是"不可变"(immutable),也就是说,我们不应该定义任何会修改实例字段的成员(值类型的字面值不是实例的字段值),也就是要将值类型的字段都标记为readonly.有个好消息是,FCL的核心值类型(Int32,Int64,Single,Double,String等以及所有枚举)都是"不可变"的,所以使用这些类型时不会发生古怪的事情
  * 对象的相等性与同一性:System.Object类型提供了名为Equals的虚方法,作用是在两个对象引用相同的对象时,返回true,假如实参引用不同对象,Euqals不肯定对象是否包含相同的值,就返回false.所以,对于Object的Equals方法的默认实现,它实现的实际是 **同一性** ,而非 **相等性**  由于其派生类可以重写Object的Equals方法,所以不能再用它测试同一性,为此Object也提供了静态方法ReferenceEquals专门检测同一性(不应当使用C#的==操作符,因为某个操作数的类型有可能重载==操作符赋予其不同于"同一性的"含义)
  * Equals方法在Object中的原型为:public virtual Boolean Equals(Object obj){...} System.ValueType(所有值类型的基类)就 **重写** 了Object的Equals方法,并进行了执行值的相等性检查(而不是同一性检查),它的内部实现过程:
    * 1.如果obj实参为null,返回false
    * 2.如果this和obj实参引用不同类型的对象,返回false
    * 3.针对类型定义的每个实例字段,都将this对象中的值与obj对象中的值进行比较(通过调用字段的Equals方法 相当于遍历两棵树??树的深度相当于继承的层次),任何字段不相等,就返回false
    * 4.返回true
  * 由于CLR的反射机制慢,定义自己的值类型时应当重写Equals方法来提供自己的实现,提高相等性比较的性能,重写Equals方法时,还需要重载==和!=操作符方法,实现这些操作符方法在内部调用类型安全的Equals
* 其它
  * FCL设计者认为,将任何对象的任何实例放到哈希表集合中,能带来很多好处.为此System.Object提供了虚方法GetHashCode,它能获取任意对象的Int32哈希码
  * dynamic基元类型 5.5章节 待深入

### 六、类型和成员基础
* 类型的各种成员
  * 类型的成员简介
    * **常量**: 常量是指出数据值恒定不变的符号,常量总与类型关联,不与类的实例关联.常量在逻辑上总是静态成员
    * **字段**: 字段表示只读或可读/可写的数据值,字段可以使静态的,这种字段是类型的一部分;字段也可以是非静态的(实例),这种字段是对象(实例)的一部分,强烈建议将字段声明为私有,防止类型或对象的状态被类型外部的代码破坏
    * **实例构造器**: 实例构造器是将新*对象*的实例字段初始化为良好初始状态的特殊方法
    * **类型构造器**: 类型构造器是将*类型*的静态字段初始化为良好初始状态的特殊方法
    * **方法**: 方法是更改或查询类型或对象状态的函数,作用于类型的方法称为静态方法;作用于对象的方法称为实例方法,方法通常要读写类型或对象的字段
    * **操作符重载**: 操作符重载本质也是方法,定义了当操作符作用于对象是,应该如何操作该对象.由于并不是所有的编程语言都支持操作符重载,所以操作符重载不是公共语言规范CLS的一部分
    * **转换操作符**: 转换操作符是定义如何隐式或显式将对象从一种类型转型为另一种类型的方法,不是CLS的一部分
    * **属性**: 属性允许用简单的,字段风格的语法设置或查询类型或对象的逻辑状态,同时保证状态不被破坏.作用于类型成为静态属性,作用于对象成为实例属性(本质是加了语法糖的方法?)
    * **事件**: 静态事件允许类型向一个或多个静态或实例方法发送通知.实例(非静态)事件允许对象向一个或多个静态或实例方法发送通知.引发事件通常是为了响应提供事件的类型或对象状态的改变. 事件包含两个方法,允许静态或实例方法登记或注销对该事件的关注.同时事件通常还用一个委托字段来维护已登记的方法集
    * **类型**: 类型可定义其他嵌套类型,通常用这个办法将大的复杂的类型分解成更小的构建单元来实现
  * 需要注意的一点是,上述成员在CLR的中间语言IL代码层面上讲均是用字段和方法来实现的,也就是它们均是为了简化常见编程模式而进行的抽象
  * 任何编程语言,所对应的编译器都能正确处理源代码,为上述每种成员生成元数据和IL代码,所有编程语言生成的元数据格式完全一致,这正是CLR成为公共语言运行时的原因.元数据是所有语言都生成和使用的公共信息,正是有了元数据,用一种语言写的代码才能无缝访问另一种语言写的代码
  * 源代码中定义的所成员都会使编译生成元数据,并且有的成员还会使编译器生成额外的成员和额外的元数据
* 类型的可见性
  * 类型的可见性一般指定为public或internal,public类型不仅对定义程序集中的所有代码可见,还对其他程序集的代码可见.internal类型则仅对定义程序集中的所有代码可见,对其它程序集中的代码不可见.定义类型的时候如果不显示指定可见性,C#编译器会自动指定为internal
  * 友元程序集:生成程序集时,可用System.Runtime.CompilerServices命名空间中的InternalsVisiableTo特性标明它认为是友元的其它程序集,该特性获取表示有缘程序集名称和公匙的字符串参数,友元程序集能够访问该程序集中所有的internal类型以及这些类型的internal成员
* 成员的可访问性
  * 定义类型的成员时,可指定成员的可访问性.在代码中引用成员时,成员的可访问性指出引用是否合法.CLR自己定义了一组可访问性的修饰符,但是编程语言在成员应用的可访问性上,都选择了自己的一组术语(关键字)以及相应的语法.例如CLR使用Assembly表明成员对同一程序集内的所有代码可见 而C#对应的术语是internal public internal protected private 详见c#
  * 在C#中 如果没有显式声明成员的可访问性,通常默认选择private(限制最大的)
  * CLR要求接口类型的所有成员都具有public可访问性,C#编译器知道这一点,因此禁止开发人员显式指定接口或成员的可访问性
* 静态类
  * 有一些永远不需要实例化的类,例如Console Math Environment和ThreadPool,这些类只有static成员,事实上这种类的唯一作用是组合一组相关的成员.在C#中 要用 **static** 关键字定义不可以实例化的类,该关键字只能用于类而不能用于结构(值类型),因为CLR总是允许值类型实例化
  * C#编译器对静态类进行了如下限制
    * 静态类必须直接从基类System.Object派生,从其它任何基类派生都没有意义
    * 静态类不能实现接口,因为只有使用类的实例时才可调用类的接口方法
    * 静态类只能定义静态成员(字段,方法,属性,事件) 任何实例成员都会导致编译器报错
    * 静态类不能违字段,方法参数,或局部变量使用,因为他们都代表了引用了实例的变量,这不被允许
  * 使用关键字static定义类,将导致C#编译器将该类标记为abstract和sealed 另外编译器不会在类型中生成实例构造器方法 因为使用IlDasm.exe反汇编工具
* 分部类,结构和接口
* 组件,多态和版本控制

### 七、常量和字段
* 常量
  * 如`public const short MaxValue = (short)0x7FFF; `
  * 常量是值从不发生变化的符号.定义常量符号时,它的值在 **编译** 时就确定了.确定后,编译器将常量的值保存到程序集元数据中,这意味着只能定义编译器识别的 **基元类型的常量** ,在C#中,Boolean,Char,Byte,SByte,Int16,Int32,UInt16,UInt32,Single,Double,String等基元类型可以定义常量.C#也循序定义非基元类型的常量变量,前提是把值设为null
  * 由于常量值从不变化,所以常量总是被视为 **类型定义** 的一部分,换言之,常量总被视为 **静态成员**,而不是实例成员,定义常量将导致创建元数据
  * 代码引用常量符号时,编译器在定义常量的程序集的元数据中查找该符号,提取常量的值,将值直接嵌入生成的IL代码中,所以运行时并 **不需要为常量分配任何内存**,而且不能获取常量的地址,不传递常量参数.因此只有确定一个符号的值从不变化才定义常量(MaxInt16定义为32767).
* 字段
  * 字段是一种 **数据成员**,其中容纳了一个值类型的实例或者对一个引用类型的引用
  * CLR支持类型(静态)字段和实例(非静态)字段,如果是类型字段,容纳字段数据所需的动态内存实在类型对象中分配的,而类型对象是在类型加载到一个AppDomain时创建的,即通常是引用了该类型的任何方法首次进行JIT编译的时候.如果是实例字段,容纳字段所需的动态内存实在构造类型的实例的时候分配
  * CLR支持readOnly字段和read/write字段,大多数字段(默认)都是read/write字段,这意味着在代码执行过程中,字段值可以多次改变.但readOnly字段只能在构造器方法中写入(构造器方法只能调用一次,即对象首次创建的时候).编译器和验证机制确保readOnly字段不会被构造器以外的任何方法写入,可以利用反射来修改readOnly字段
  * ```public static readonly Random s_random=new Random();```  
  在上述代码中,许多字段都是 **内敛(inline)初始化** 的.C#允许使用这种简便的内敛初始化语法来初始化类型常量,write/read字段,和readonly字段.这种方法 **本质上** 也是在构造器中对字段进行初始化,字段的内敛初始化只是一种语法上的简化.但是使用内敛语法而不是在构造器中赋值会有一些性能问题需要考虑
  * 当某个字段是引用类型,而且该字段被标记为readonly时,不可改变的是引用,而非字段引用的对象(就是不能再让该变量引用其它的对象了)


  |CLR术语|C#术语|说明
  |:-:|:-:|:-:
  |Static|static|这种字段是类型状态的一部分,不是对象状态的一部分
  |Instance|(默认)|这种字段与类型的一个实例关联.不是与类型本身关联
  |InitOnly|readonly|只读字段,这种字段只能由一个构造器方法中的代码写入
  |Volatile|volatile|(易变)编译器,CLR和硬件不会对访问这种字段的代码执行"线程不安全"的优化措施

### 八、方法
* 实例构造器和类(引用类型)
  * **构造器** 是将类型的实例初始化为良好状态的特殊方法.构造方法在"方法定义元数据表"中始终叫做.ctor(constructor的简称).创建引用类型的实例时,首先为实例的数据字段分配内存,然后初始化对象的附加字段(类型对象指针和同步块索引),最后调用类型的实例构造器来设置对象的初始状态.
  * 构造引用类型的对象时,在调用类型的实例构造器之前,为对象分配的内存总是先被 **归零**,没有被构造器显式初始化的所有字段都保证获得0或null值(VS验证 int被初始化成null 跟tm没初始化没啥区别)
  * 和其它方法不同,实例构造器永远不能被继承,也就是类只有类自己定义的构造器.如果类没有显式定义任何构造器.C#编译器将定义一个默认(无参)构造器.在它的实现中,只是简单地调用了基类的无参构造器.即默认如下构造器  
  `public SomeType():base(){}`  
  * 一个类型可以定义多个实例构造器,每个构造器都必须有不同的 **签名** 而且每个都可以有不同的"可访问性".为了使代码"可验证",类的实例构造器在访问从基类生成的任何字段之前,必须先调用基类的构造器.如果派生类的构造器没有显式调用一个基类构造器,C#编译器会自动生成对默认的基类构造器的调用.最终,System.Object的公共无参构造器会被调用,该构造器什么都不做直接返回
  * 静态类(static)在元数据中是抽象密封类(abstract&sealed)
  * C#提供了一种简化的语法,允许以  **内联**(其实就是嵌入)方式初始化实例字段,但在幕后,它会将这种语法转换成构造器方法中的代码来执行初始化,这提醒我们要注意代码的膨胀效应  
  * 编译器在为自定义的实例构造器方法生成(IL)代码时
    * 1.在方法的开始位置,会包含用于初始化内联字段的代码
    * 2.在这些初始化代码之后,编译器会插入对基类构造器的调用
    * 3.然后,编译器会插入构造器方法自己的代码
  * 如果有几个已内联初始化的实例字段和许多重载的构造器方法,可考虑不是在定义字段时内联初始化,而是创建单个构造器来执行这些公共的初始化,然后让其它构造都显式调用这个公共初始化构造器,这样能减少生成的代码.在C#中可以利用:this关键字显式调用另一个构造器  
  `public SomeType(Int32 x):this(){...}`  
  上面的重载构造器利用:this()显式调用了无参构造器SomeType()
* 实例构造器和结构(值类型)
  * 值类型(struct)构造器的工作方式与引用类型(class)构造器 **截然不同**.CLR总是允许创建值类型的实例,并且没有办法阻止值类型的实例化(因为只要声明了一个值类型实例 不需要new它的实例就已经创建了,内存已经分配了).所以值类型不需要定义构造器.C#编译器根本不会为值类型内联(嵌入)构造器
  * 但是CLR允许为值类型定义构造器,但必须显式调用才会执行,即需要用关键字new来显式调用实例构造器.并且C#编译器故意不允许值类型定义无参构造器,目的是为了防止开发人员对这种构造器什么时候调用产生迷惑.由于不能定义无参构造器,所以编译器永远不会生成自动调用它的代码,没有无参构造器,值类型的字段总是被初始化为0或null(VS验证:结构中的int被初始化为0,可以直接使用)
  * 因为C#编译器不允许为值类型定义无参构造器,所以不允许直接在声明字段处内联初始化,编译器会报错:结构中不能有实例字段初始值设定项
  * 注意:严格说 只有当值类型的字段嵌套到 **引用类型** 中时,才保证初始化为0或null, **基于栈** 的值类型字段则无此保证.为了确保代码的"可验证性",任何基于栈的值类型字段都必须在读取之前写入(赋值),确保不会在运行时因验证失败而抛出异常,否则无法通过编译,会报错"使用了未赋值的局部变量"(通过编译的条件是所有变量都要初始化,初始成null也算初始化过)
* 类型构造器
  * 除了实例构造器,CLR还支持 **类型构造器** ,也称 **静态构造器** , **类构造器** ,或者 **类型初始化器**.类型构造器可以应用于接口(虽然C#编译器不允许)、引用类型和值类型. 实例构造器的作用是设置类型的实例的初始状态,对应的,类型构造器的作用是设置类型的初始状态.类型默认没有定义类型构造器,并且开发人员最多定义一个类型构造器(不可重载,只有一个无参构造器),即类型构造器不能有参数
  * 类型构造器的几个特点
    * 如`static SomeType(){}`
    * 必须标记为static
    * 没有返回值
    * 不可以显式出现访问修饰符 因为C#编译器会自动把它们标记为private.之所以必须私有,是为了防止任何由开发人员写的代码调用它,对它的调用总是由CLR负责
    * 只能访问类型中的静态字段(而且它的常规用途就是初始化这些静态字段),同实例字段一样,静态字段也可以内联初始化.
  * 关于类型构造器的调用内部机制:  
  JIT编译器在编译一个方法时,会查看代码中引用了哪些类型,如果任何一个类型定义了类型构造器,JIT编译器会检查当前AppDomain是否已经执行了这个构造器,如果构造器从未执行,JIT编译器会在它生成的本机(naive)代码中添加对类型构造器的调用.如果类型构造器已经执行,JIT编译器就不添加对它的调用,因为它知道类型已经初始化好了.现在,当方法被JIT编译完毕后,线程开始执行它,最终会执行到调用类型构造器的代码,事实上,多个线程可能同时执行相同的方法.CLR希望确保在每个AppDomain中一个类型构造器只执行一次.为了保证这一点,在调用类型构造器时,调用线程需要获取一个**互斥线程同步锁**,这样一来,如果多个线程试图同时调用某个类型的静态构造器,只有一个线程才可以获得锁,其它线程会被阻塞(blocked).第一个线程会执行类型构造器的代码,当第一个线程离开构造器后,正在等待的线程被唤醒,然后发现类型构造器的代码已经被执行过,因此,这些线程不会在此执行代码,将直接从构造器方法返回.除此之外,如果再次调用这样的一个方法,CLR知道类型构造器已经被执行过,从而确保类型构造器不被再次调用.
  * 由于CLR保证一个类型构造器在每个AppDomain中只执行一次,而且这种执行是线程安全的,所以非常适合在类型构造器中初始化类型需要的任何 **单实例对象** (单例模式)
  * 不同于实例构造器,类型构造器在编译时不会自动插入调用基类的类型构造器,这种调用也是没有必要的,因为类型不可能有任何静态字段是从基类继承来的(静态字段只属于类型自己)  
  * 也就是编译器在为自定义的类型构造器方法生成(IL)代码时只有两步:
    * 1.在方法的开始位置,会包含用于初始化内联静态字段的代码
    * 2.然后,插入类型构造器方法自己的代码
  * 类型只有在AppDomain卸载时才会卸载,AppDomain卸载时,用于表示类型的对象(类型对象)将成为不可达的对象(不存在对它的引用),垃圾回收器会回收类型对象的内存
* 操作符重载方法
  * 有的语言允许类型定义操作符应该如何操作类型的实例.例如许多类型(System.String)都重载了相等(==)和不等(!=)操作符.但是,**CLR对操作符重载一无所知** 它甚至不知道什么是操作符。。。卧槽好犀利的见解.是编程语言定义了每个操作符的含义,以及当这些符号出现时,应该生成什么样的代码 例如在C#中,像基元类型应用+符号,编译器生成将两个数加到一起的代码,将+符号应用于String对象,C#编译器生成将两个字符串连接到一起的代码.
  * 虽然CLR对操作符一无所知,但是它规定了语言应当如何公开操作符重载,以便由另一种语言使用,每种编程语言都要自行决定是否使用操作符重载.如果决定支持,还要决定使用什么样的语法来表示和使用它们.
  * 需要注意的几点
    * CLR规范要求操作符重载方法必须是public和sealed方法.
    * 另外,C#(以及许多其它语言)都要求操作符重载方法至少有一个参数的类型与当前定义这个方法的类型相同(目的是使C#编译器能在合理的时间内找到要绑定的操作符方法)
    * C#代码示例:SomeType类重载加号操作符:  
    `public static SomeType operator+(SomeType s1,SomeType s2){return null;}`
  * 根据Microsoft的设计规范,重载了op_Addition方法的类型应定义一个公共的,名字更 **友好** 的Add方法,每个操作符都有推荐的相容与CLS的对应方法名 如上述示例代码应该像下面这样定义两个方法:  
  `public static SomeType operator+(SomeType s1,SomeType s2){return ...;}`  
  `public static SomeType Add(SomeType s1,SomeType s2){return s1+s2;}`
* 转换操作符方法
  * 本质是在类型的内部对类型转换操作的一级 **封装**
  * 有时需要将对象从一种类型转换为另一种类型(例如将Byte转换为Int32).当源类型和目标类型都是编译器识别的 **基元类型** 时,编译器自己就知道如何生成转换对象所需的代码(FCL已经写好了?)
  * 如果源类型或目标类型不是基元类型,编译器会生成代码要求CLR执行转换(强制转换).这种情况下,CLR只是检查源对象的类型和目标类型(或者从目标类型派生的其它类型)是否相同.但有时需要将一种类型转换成 **全然不同** 的其它类型.为了进行这样的转换,该类型应该定义只有一个参数的公共构造器,该参数是源类型的实例.还应该定义无参的公共实例方法Toxxx(类似于ToString),下面会有代码展示如何为SomeType类型正确定义 **转换构造器** 和方法
  * 转换操作符使将对象从一种类型转换为另一种类型的 **特殊方法** ,C#允许使用特殊的语法来定义转换操作符方法.CLR规范要求转换操作符重载方法必须是public和static方法.此外,还要求参数类型和返回类型二者之一必有其一与定义转换方法的类型相同(与操作符重载方法相似)   
    public sealed class SomeType{  
    //无参构造器  
    public SomeType(){...}  
    //由Int32构造的SomeType  
    public SomeType(Int32 num){...}  
    //由Single构造的SomeType  
    public SomeType(Single num){...}  
    //将SomeType转换为Int32并返回该值 实例方法,无参  
    public Int32 ToInt32(){...}  
    //将SomeType转换为Single并返回该值 实例方法,无参  
    public Single ToSingle(){...}  
    /******上面的是传统方法,下面使用特殊的语法定义转换操作符方法*****/  
    //由一个Int32隐式构造并返回一个SomeType  
    public static implicit operator SomeType(Int32 num){return new SomeType(num);}  
    //由一个SomeType显式返回一个Single  
    public static explicit operator Single(SomeType st){return st.ToSingle();}  
  }
  * 在C#中,**implicit** 关键字告诉编译器隐式类型转换的时候调用此方法 **explicit** 关键字告诉编译器只有在发现了显式转型时,才调用方法
  * **注意,方法的签名不包括返回值** 只包括方法名和参数列表,不包括返回值,除了极少数语言如(IL汇编语言)支持通过返回类型区别多个方法的能力,在两个关键字之后,指定 **operation** 关键字告诉编译器该方法是一个 **转换操作符** .在operation之后,指定对象要转换成什么类型(返回值的位置),在圆括号内(参数位置),指定要从什么类型转换
  * C#编译器提供了对转换操作符的完全支持.如果检测到代码中正在使用某个类型的对象,而实际期望的是另一种类型的对象.编译器就会查找能执行这种转换的隐式操作符方法,并生成代码来调用该方法.如果编译器看到源代码是将对象从一种类型显式转换为另一种类型,就会查找能执行这种换换的隐式或显式操作符方法,如果能找到,编译器会生成IL代码来调用它,如果找不到,就报错并停止编译.
* 扩展方法
  * 将该方法的参数类型和调用该方法的类型 **相互关联** ,使彼此都能单向操作.在 **工厂设计模式** 中用处较大,可以实现即使不知道工厂类型的存在也可以调用工厂类型中的方法(通过该方法的参数类型)
  * **扩展方法** 的引入:  
  `StringBuilder sb=new StringBuilder("hello,my name is Jeff!");`对比下面两段代码的**表现力**  
  1.`Int32 index=StringBuilderExtensions.IndexOf(sb.Replace('.','!'),'!');`  
  2.`Int32 index=sb.Replace('.','!').IndexOf('!');`  
  毋庸置疑,站在开发人员的角度,第二种的表现力要更强.在第一种写法中,要获取一个StringBuilder中的某个字符的索引,必须先知道StringBuilderExtensionsde类的存在.它影响了我们对代码行为的理解.使用StringBuilderExtensions显得有些小题大做,使程序员无法 **专注于当前操作**.所以我们设想,如果StringBuilder类定义了自己的IndexOf方法就好了.由此,我们就很容易理解C#扩展方法的意义了.
  * 我们允许定义一个静态方法,并用实例方法的语法调用,只需在这个方法的第一个参数前添加 **this关键字** ,就可以使用该参数类型的实例直接调用此方法  
  `public static Int32 IndexOf(this StringBuilder sb,Char value){...}`  
  所以,我们可以推测出编译器调用方法的额外工作,当编译器看到以下代码:`Int32 index =sb.IndexOf('X');`时,首先检查StringBuilder类或者它的任何基类是否提供了获取单个Char参数,名为IndexOf的一个实例方法.如果是,就生成IL代码来调用它,如果没有找到匹配的实例方法,就继续检查是否有任何静态类定义了名为IndexOf的静态方法,方法第一个参数为StringBuilder,并且用this关键字标识
  * 还有一个问题是,程序员在只拿到StringBuilder类的前提下知道有这样一个IndexOf方法(并不在StringBuilder类中定义),可以操作StringBuilder对象呢?-------可以通过Microsoft visual studio的"智能感知"窗口,列出当前可用的实例方法,也会列出可作用于句点左侧表达式类型的扩展方法.现在我们可以轻松定义自己的方法来操作各种类型,其它程序员在使用这些类型的对象时,也能轻松地发现你的方法.
  * 规则和原则
    * C#只支持扩展方法,不支持扩展属性,扩展事件,扩展操作符等(尽管在CLR层面他们的本质也是方法)
    * 扩展方法必须在 **非泛型的静态类** 中声明,并且扩展方法只有第一个参数能用this关键字标记
    * 定义扩展方法的静态类本身需要有 **文件作用域**(即在命名空间中public或internal,不能够是嵌套类),因为C#编译器需要在静态类中查找扩展方法
    * 为增强性能并避免找到非你所愿的扩展方法,C#编译器要求在使用扩展方法的源代码中导入扩展方法所在类的命名空间(使用using指令)
    * 使用扩展方法这个功能须谨慎,在用一个扩展方法扩展一个类型时,同时也就扩展了其派生类型,所以,不要将System.Object作为扩展方法的第一个参数,否则这个方法在所有表达式类型上都能调用,造成"智能感知"被填充太多 **垃圾信息**
    * 版本控制问题是使用扩展方法必须谨慎的原因之一
* 分部方法

### 九、参数
* 可选参数和命名参数
  *
  






---

* 关于dll的理解
  * DLL(Dynamic Link Library)文件即动态链接库文件，又称为"应用程序扩展" 在Windows中许多应用程序不是完整的可执行文件而是被分割成一些相对独立的动态链接库，当我们执行某一个程序时相应的dll文件会被调用。使用DLL的好处是不需要再运行之初加载(编译？)所有代码，只有在程序需要调用某个函数时才从dll中取出，使程序实现模块化，只有模块在相应功能被请求时才加载。对于实现 **更新** 意义重大，把某些逻辑代码放到dll中，需要改变某些功能时无需重新生成或安装整个程序，只需要更新DLL就能实现更新
