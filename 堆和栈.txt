栈是一个有逻辑顺序的结构，堆则是杂乱地堆在一起的，引用类型占空间较大故不直接存在栈中而是存放在堆中，
通过栈中的指针引用，而值类型由于本来就小没必要再开辟一个引用，索性直接存放在栈中

同样，值类型如果作为类的字段或者属性也是会存在堆中的。而由于堆相对比较耗性能，
所以如果让值类型这些简单类型也存在堆中就显得没必要的，而栈正好适用与值类型

编译器就是这么设定的，引用类型变量是分配在栈中用来存放实例的引用，而如果引用类型变量作为类的字段或者属性那么就随该类的实例存在堆中。

java中的规则 c#应该类似
{

一种是基本类型(primitivetypes), 共有8种，即int,short, long, byte, float, double, boolean, char(注意，并没有string的基本类型) 

这种类型的定义是通过诸如int a= 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，
不是类的实例，即不是类的引用，这里并没有类的存在。如int a= 3; 这里的a是一个指向int类型的引用，指向3这个字面值。
这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。
另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：int a=3;int b=3;
编译器先处理int a= 3；首先它会在栈中创建一个变量为a的内存空间，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。
接着处理int b= 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。
特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，
那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。
如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；
如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。


另一种是包装类数据，【如Integer,String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于【堆】中】，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 

String是一个特殊的包装类数据。即可以用String str = new String("abc");的形式来创建，也可以用String str = "abc"；的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = "abc"；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。
4. 关于String str = "abc"的内部工作。Java内部将此语句转化为以下几个步骤：【String str = "abc"，String str不要连着】
(1)先定义一个名为str的对String类的对象引用变量：String str；
(2)【在【栈】中查找有没有存放值为"abc"的地址，如果没有，则开辟一个存放字面值为"abc"的地址，接着创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。】【上文说数据时存放在堆中，此文说数据存放在栈中】[因为此处不是通过new（）创建的啊]
(3)将str指向对象o的地址。
值得注意的是，一般String类中字符串值都是直接存值的。但像String str = "abc"；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！

}